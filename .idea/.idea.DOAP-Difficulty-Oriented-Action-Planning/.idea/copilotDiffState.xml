<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/GOAP/STANDGUARD_ARCHITECTURE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/GOAP/STANDGUARD_ARCHITECTURE.md" />
              <option name="updatedContent" value="# StandGuard Action - Component Architecture&#10;&#10;## Component Flow Diagram&#10;&#10;```&#10;┌─────────────────────────────────────────────────────────────────────────────┐&#10;│                          GOAP PLANNING SYSTEM                                │&#10;└─────────────────────────────────────────────────────────────────────────────┘&#10;                                     │&#10;                                     ▼&#10;┌─────────────────────────────────────────────────────────────────────────────┐&#10;│                         StandGuardCapability.asset                           │&#10;│  ┌────────────────────────────────────────────────────────────────────────┐ │&#10;│  │  GOAL: StandGuardGoal (baseCost: 0.5)                                  │ │&#10;│  │  Conditions:                                                            │ │&#10;│  │    ✓ Difficulty ≥ 75                                                   │ │&#10;│  │    ✓ AtStandGuardPoint ≤ 1 (within 5m)                                │ │&#10;│  │    ✓ Energy &gt; 0                                                        │ │&#10;│  │    ✓ LastStoodGuard &gt; 15 (seconds)                                    │ │&#10;│  └────────────────────────────────────────────────────────────────────────┘ │&#10;│  ┌────────────────────────────────────────────────────────────────────────┐ │&#10;│  │  ACTION: StandGuardAction (baseCost: 0.5)                             │ │&#10;│  │  Target: StandGuardTarget (nearest guard point)                        │ │&#10;│  │  Same conditions as goal + IsAlert ≤ 0                                │ │&#10;│  └────────────────────────────────────────────────────────────────────────┘ │&#10;└─────────────────────────────────────────────────────────────────────────────┘&#10;                                     │&#10;                    ┌────────────────┼────────────────┐&#10;                    ▼                ▼                ▼&#10;        ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐&#10;        │  WORLD SENSORS  │  │ TARGET SENSORS  │  │  ACTION CODE    │&#10;        └─────────────────┘  └─────────────────┘  └─────────────────┘&#10;                 │                    │                     │&#10;        ┌────────┼────────┐          │                     │&#10;        ▼        ▼        ▼          ▼                     ▼&#10;    ┌────────────────────────────────────────────────────────────────────────┐&#10;    │                        SENSOR LAYER                                     │&#10;    ├────────────────────────────────────────────────────────────────────────┤&#10;    │  DifficultySensor              → Difficulty WorldKey (0-100)           │&#10;    │    └─ Reads: DifficultyTracker.GetDifficultyF() * 100                  │&#10;    │                                                                         │&#10;    │  AtStandGuardPointSensor       → AtStandGuardPoint WorldKey (0/1)     │&#10;    │    └─ Checks: Distance to any &quot;StandGuardPoint&quot; ≤ 5m                  │&#10;    │                                                                         │&#10;    │  LastStoodGuardSensor          → LastStoodGuard WorldKey (seconds)    │&#10;    │    └─ Reads: StandGuardTimerBehaviour.GetTimeSinceLastGuard()        │&#10;    │                                                                         │&#10;    │  StandGuardTargetSensor        → StandGuardTarget TargetKey (Vector3) │&#10;    │    └─ Finds: Nearest GameObject tagged &quot;StandGuardPoint&quot;              │&#10;    │                                                                         │&#10;    │  EnergySensor (existing)       → Energy WorldKey (0-100)              │&#10;    │    └─ Reads: EnergyBehaviour.CurrentEnergy                            │&#10;    └────────────────────────────────────────────────────────────────────────┘&#10;                                     │&#10;                                     ▼&#10;    ┌────────────────────────────────────────────────────────────────────────┐&#10;    │                      StandGuardAction.cs                                │&#10;    ├────────────────────────────────────────────────────────────────────────┤&#10;    │  Created() - Initialize action                                          │&#10;    │  IsValid() - Check if target still valid                               │&#10;    │  Start()   - Begin moving to guard point, set animation to Walk        │&#10;    │  Perform() - Main execution loop:                                       │&#10;    │    ┌──────────────────────────────────────────────────────────────┐   │&#10;    │    │  PHASE 1: MOVEMENT                                            │   │&#10;    │    │  • Move to StandGuardPoint using NavMeshAgent                │   │&#10;    │    │  • Check distance: if ≤ 1.5m, proceed to Phase 2             │   │&#10;    │    │  • Animation: Walk                                            │   │&#10;    │    └──────────────────────────────────────────────────────────────┘   │&#10;    │    ┌──────────────────────────────────────────────────────────────┐   │&#10;    │    │  PHASE 2: GUARD DUTY (10 seconds)                            │   │&#10;    │    │  • Stop NavMeshAgent                                          │   │&#10;    │    │  • Find 2 nearest &quot;StandGuardAnglePoint&quot; objects             │   │&#10;    │    │  • Rotate body between the two angle points                   │   │&#10;    │    │  • Rotation: Slerp at ROTATION_SPEED = 2 rad/s               │   │&#10;    │    │  • Switch direction when within 5° of target                  │   │&#10;    │    │  • Animation: Idle                                            │   │&#10;    │    │  • Timer: guardTime += Time.deltaTime                        │   │&#10;    │    │  • When guardTime ≥ 10s: return Completed                    │   │&#10;    │    └──────────────────────────────────────────────────────────────┘   │&#10;    │  Complete() - Add/start StandGuardTimerBehaviour cooldown             │&#10;    │  End()      - Resume NavMeshAgent movement                             │&#10;    └────────────────────────────────────────────────────────────────────────┘&#10;                                     │&#10;                                     ▼&#10;    ┌────────────────────────────────────────────────────────────────────────┐&#10;    │               StandGuardTimerBehaviour (Component)                      │&#10;    ├────────────────────────────────────────────────────────────────────────┤&#10;    │  • Attached to guard GameObject dynamically on first completion        │&#10;    │  • Tracks lastGuardTime (Time.time when guard completed duty)         │&#10;    │  • StartCooldown() - Called by StandGuardAction.Complete()            │&#10;    │  • GetTimeSinceLastGuard() - Returns Time.time - lastGuardTime        │&#10;    │  • Prevents guard from standing guard again for 15 seconds            │&#10;    └────────────────────────────────────────────────────────────────────────┘&#10;```&#10;&#10;## Condition Evaluation Flow&#10;&#10;```&#10;┌─────────────────────────────────────────────────────────────────────────────┐&#10;│                          Every Frame Check                                   │&#10;└─────────────────────────────────────────────────────────────────────────────┘&#10;                                     │&#10;                ┌────────────────────┼────────────────────┐&#10;                ▼                    ▼                    ▼&#10;    ┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐&#10;    │  Difficulty ≥ 75 │  │ Within 5m of     │  │   Energy &gt; 0     │&#10;    │                  │  │  guard point     │  │                  │&#10;    │  DifficultySensor│  │AtStandGuardPoint │  │  EnergySensor    │&#10;    └──────────────────┘  │     Sensor       │  └──────────────────┘&#10;                          └──────────────────┘&#10;                ▼                    ▼                    ▼&#10;                └────────────────────┼────────────────────┘&#10;                                     │&#10;                        ┌────────────┴────────────┐&#10;                        ▼                         ▼&#10;            ┌──────────────────────┐  ┌──────────────────────┐&#10;            │LastStoodGuard &gt; 15s  │  │    IsAlert ≤ 0      │&#10;            │                      │  │                      │&#10;            │LastStoodGuardSensor  │  │   AlertSensor        │&#10;            └──────────────────────┘  └──────────────────────┘&#10;                        │                         │&#10;                        └────────────┬────────────┘&#10;                                     ▼&#10;                          ┌─────────────────────┐&#10;                          │  ALL CONDITIONS MET │&#10;                          │         ↓           │&#10;                          │ Interrupt Patrol    │&#10;                          │ Start StandGuard    │&#10;                          └─────────────────────┘&#10;```&#10;&#10;## Scene Setup&#10;&#10;```&#10;Unity Scene Hierarchy:&#10;├── Guard (your guard GameObject)&#10;│   ├── NavMeshAgent (component)&#10;│   ├── GoapActionProvider (component)&#10;│   ├── BrainBehaviour (component)&#10;│   ├── EnergyBehaviour (component)&#10;│   ├── GuardAnimation (component)&#10;│   ├── ActionAudioBehaviour (component)&#10;│   └── [StandGuardTimerBehaviour] (added automatically on first guard duty)&#10;│&#10;├── Environment&#10;│   ├── StandGuardPoint_1 (empty GameObject)&#10;│   │   └── Tag: &quot;StandGuardPoint&quot;&#10;│   │&#10;│   ├── StandGuardPoint_2 (empty GameObject)&#10;│   │   └── Tag: &quot;StandGuardPoint&quot;&#10;│   │&#10;│   ├── AnglePoint_Left (empty GameObject, near StandGuardPoint_1)&#10;│   │   └── Tag: &quot;StandGuardAnglePoint&quot;&#10;│   │&#10;│   ├── AnglePoint_Right (empty GameObject, near StandGuardPoint_1)&#10;│   │   └── Tag: &quot;StandGuardAnglePoint&quot;&#10;│   │&#10;│   ├── AnglePoint_Left2 (empty GameObject, near StandGuardPoint_2)&#10;│   │   └── Tag: &quot;StandGuardAnglePoint&quot;&#10;│   │&#10;│   └── AnglePoint_Right2 (empty GameObject, near StandGuardPoint_2)&#10;│       └── Tag: &quot;StandGuardAnglePoint&quot;&#10;│&#10;└── GoapManager (GameObject with GoapBehaviour)&#10;    └── GuardAgentTypeFactory (component)&#10;        └── Capabilities List:&#10;            ├── PatrolCapability.asset&#10;            ├── PursuitCapability.asset&#10;            ├── CatchCapability.asset&#10;            ├── RechargeCapability.asset&#10;            └── StandGuardCapability.asset  ← ADD THIS&#10;```&#10;&#10;## Priority System&#10;&#10;```&#10;Action Priority (Lower baseCost = Higher Priority):&#10;┌────────────────────────────────────────────────────────┐&#10;│  Priority  │  Action          │  baseCost  │  Trigger  │&#10;├────────────────────────────────────────────────────────┤&#10;│  HIGHEST   │  CatchAction     │    0.1     │  At Player│&#10;│            │  PursuitAction   │    0.3     │  See Player│&#10;│            │  StandGuardAction│    0.5     │  Hi-Diff  │ ← NEW&#10;│            │  RechargeAction  │    4.0     │  Low Energy│&#10;│  LOWEST    │  PatrolAction    │    1.0     │  Default  │&#10;└────────────────────────────────────────────────────────┘&#10;&#10;Result: StandGuard will INTERRUPT Patrol when conditions are met!&#10;```&#10;&#10;## Data Flow&#10;&#10;```&#10;┌─────────────────────────────────────────────────────────────────┐&#10;│                    EXTERNAL SYSTEMS                              │&#10;├─────────────────────────────────────────────────────────────────┤&#10;│  DifficultyTracker.GetDifficultyF()     → float (0.0 - 1.0)    │&#10;│  GameObject.FindGameObjectsWithTag()    → GameObject[]          │&#10;│  StandGuardTimerBehaviour               → float (seconds)       │&#10;│  EnergyBehaviour.CurrentEnergy          → float (0-100)         │&#10;│  NavMeshAgent                           → Movement/Rotation     │&#10;└─────────────────────────────────────────────────────────────────┘&#10;                           ▼&#10;┌─────────────────────────────────────────────────────────────────┐&#10;│                      SENSOR LAYER                                │&#10;├─────────────────────────────────────────────────────────────────┤&#10;│  Converts external data → GOAP WorldKeys/TargetKeys            │&#10;│  • Difficulty: 0.75 → 75 (int)                                  │&#10;│  • AtGuardPoint: distance check → 0/1 (bool as int)           │&#10;│  • LastStoodGuard: timer → seconds (int)                       │&#10;│  • GuardTarget: nearest point → Vector3 (PositionTarget)       │&#10;└─────────────────────────────────────────────────────────────────┘&#10;                           ▼&#10;┌─────────────────────────────────────────────────────────────────┐&#10;│                   GOAP RESOLVER                                  │&#10;├─────────────────────────────────────────────────────────────────┤&#10;│  Evaluates all goals/actions → Creates action plan             │&#10;│  • Compares baseCosts                                           │&#10;│  • Checks conditions                                            │&#10;│  • Selects optimal action                                       │&#10;└─────────────────────────────────────────────────────────────────┘&#10;                           ▼&#10;┌─────────────────────────────────────────────────────────────────┐&#10;│                 STANDGUARDACTION EXECUTION                       │&#10;├─────────────────────────────────────────────────────────────────┤&#10;│  Receives target → Moves guard → Stands for 10s → Complete     │&#10;│  • Manipulates NavMeshAgent                                     │&#10;│  • Controls rotation manually                                   │&#10;│  • Triggers animations                                          │&#10;│  • Starts cooldown timer                                        │&#10;└─────────────────────────────────────────────────────────────────┘&#10;```&#10;&#10;## State Machine&#10;&#10;```&#10;┌─────────────┐&#10;│   PATROL    │ ← Default behavior&#10;└──────┬──────┘&#10;       │ Conditions met:&#10;       │ • Difficulty ≥ 75&#10;       │ • Within 5m of guard point&#10;       │ • Energy &gt; 0&#10;       │ • Cooldown expired (&gt;15s)&#10;       ▼&#10;┌─────────────────────────┐&#10;│ STANDGUARD - MOVING     │&#10;│ • NavMeshAgent active   │&#10;│ • Walk animation        │&#10;│ • Target: guard point   │&#10;└───────────┬─────────────┘&#10;            │ Distance ≤ 1.5m&#10;            ▼&#10;┌─────────────────────────┐&#10;│ STANDGUARD - ON DUTY    │&#10;│ • NavMeshAgent stopped  │&#10;│ • Idle animation        │&#10;│ • Rotating between      │&#10;│   angle points          │&#10;│ • Timer: 0→10s          │&#10;└───────────┬─────────────┘&#10;            │ Timer ≥ 10s&#10;            ▼&#10;┌─────────────────────────┐&#10;│ STANDGUARD - COMPLETE   │&#10;│ • Start 15s cooldown    │&#10;│ • Add timer behaviour   │&#10;└───────────┬─────────────┘&#10;            │&#10;            ▼&#10;┌─────────────┐&#10;│   PATROL    │ ← Resume patrol&#10;└─────────────┘&#10;     │&#10;     │ After 15s cooldown expires&#10;     └──────┐&#10;            │ If conditions still met&#10;            ▼&#10;     ┌──────────────┐&#10;     │ STANDGUARD   │ ← Can guard again&#10;     └──────────────┘&#10;```&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/GOAP/STANDGUARD_CHECKLIST.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/GOAP/STANDGUARD_CHECKLIST.md" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="# StandGuard Action - Quick Setup Checklist&#10;&#10;## ✅ Pre-Unity Steps (Completed)&#10;- [x] WorldKeys created (AtStandGuardPoint, LastStoodGuard, Difficulty)&#10;- [x] TargetKeys created (StandGuardTarget)&#10;- [x] Sensors created (4 sensors)&#10;- [x] Behaviour created (StandGuardTimerBehaviour)&#10;- [x] Action updated (StandGuardAction.cs)&#10;- [x] Capability created (StandGuardCapability.asset)&#10;- [x] Goal exists (StandGuardGoal.cs)&#10;&#10;##  Unity Setup Steps&#10;&#10;### Step 1: Add Unity Tags&#10;1. In Unity, go to **Edit → Project Settings → Tags and Layers**&#10;2. Add new tags:&#10;   - [ ] `StandGuardPoint`&#10;   - [ ] `StandGuardAnglePoint`&#10;&#10;### Step 2: Create Scene Objects&#10;1. Create guard points in your scene:&#10;   - [ ] Create empty GameObject at first guard location&#10;   - [ ] Rename to &quot;GuardPoint_1&quot;&#10;   - [ ] Tag it with `StandGuardPoint`&#10;   - [ ] Repeat for additional guard points (optional)&#10;&#10;2. Create angle points for each guard point:&#10;   - [ ] Create empty GameObject to the LEFT of GuardPoint_1&#10;   - [ ] Rename to &quot;AnglePoint_Left_1&quot;&#10;   - [ ] Tag it with `StandGuardAnglePoint`&#10;   - [ ] Create empty GameObject to the RIGHT of GuardPoint_1&#10;   - [ ] Rename to &quot;AnglePoint_Right_1&quot;&#10;   - [ ] Tag it with `StandGuardAnglePoint`&#10;   - [ ] Position them to define guard's viewing arc&#10;   - [ ] Repeat for each guard point&#10;&#10;**Example Positioning:**&#10;```&#10;        AnglePoint_Left_1&#10;               |&#10;               |&#10;               ▼&#10;         GuardPoint_1 ──────► AnglePoint_Right_1&#10;               ▲&#10;               |&#10;         (Guard stands here and rotates between angles)&#10;```&#10;&#10;### Step 3: Configure GOAP System&#10;1. Find the GameObject with **GoapBehaviour** component&#10;2. Find the **GuardAgentTypeFactory** component on that object&#10;3. In the **Capabilities** list:&#10;   - [ ] Click the **+** button&#10;   - [ ] Drag **StandGuardCapability.asset** into the new slot&#10;   - [ ] Verify it's in the list with other capabilities&#10;&#10;### Step 4: Verify Guard Setup&#10;On each Guard GameObject, verify these components exist:&#10;- [ ] NavMeshAgent&#10;- [ ] GoapActionProvider&#10;- [ ] BrainBehaviour&#10;- [ ] EnergyBehaviour&#10;- [ ] GuardAnimation (or your animation controller)&#10;- [ ] ActionAudioBehaviour&#10;- [ ] PatrolRouteBehaviour (for patrol)&#10;&#10;**Note:** StandGuardTimerBehaviour will be added automatically when guard first completes guard duty.&#10;&#10;### Step 5: Test Setup (Static Difficulty)&#10;1. Start Unity in **Static Difficulty Mode**:&#10;   - [ ] Set difficulty to **75% or higher**&#10;2. Move a guard within **5 meters** of a StandGuardPoint&#10;3. Verify guard has **energy &gt; 0**&#10;4. Expected behavior:&#10;   - [ ] Guard interrupts patrol&#10;   - [ ] Guard walks to nearest StandGuardPoint&#10;   - [ ] Guard stops at point (within 1.5m)&#10;   - [ ] Guard rotates body between two angle points for 10 seconds&#10;   - [ ] Guard resumes patrol after 10 seconds&#10;   - [ ] Guard cannot stand guard again for 15 seconds&#10;&#10;### Step 6: Test Setup (Dynamic Difficulty)&#10;1. Start Unity in **Dynamic Difficulty Mode**&#10;2. Play until difficulty reaches **≥75%** (you can monitor in console logs)&#10;3. Move a guard near a StandGuardPoint&#10;4. Verify same behavior as Step 5&#10;&#10;##  Troubleshooting&#10;&#10;### Guard never stands guard&#10;Check these in order:&#10;- [ ] Tags are spelled correctly (case-sensitive!)&#10;- [ ] At least one StandGuardPoint exists in scene&#10;- [ ] Difficulty is ≥75 (check with `Debug.Log(DifficultyTracker.GetDifficultyF())`)&#10;- [ ] Guard is within 5 meters of a guard point&#10;- [ ] Guard has energy &gt; 0&#10;- [ ] 15-second cooldown has expired (check console for timer logs)&#10;- [ ] StandGuardCapability.asset is in GuardAgentTypeFactory&#10;- [ ] Unity has compiled the new scripts (check for compilation errors)&#10;&#10;### Guard stands but doesn't rotate&#10;- [ ] At least 2 StandGuardAnglePoint objects exist in scene&#10;- [ ] Angle points are tagged correctly&#10;- [ ] Angle points are NOT at the exact same position as guard point&#10;- [ ] Angle points are visible in scene (not disabled)&#10;- [ ] Check console for log: `[StandGuardAction] Found angle points: ...`&#10;&#10;### Guard gets stuck at guard point&#10;- [ ] StandGuardPoint is on valid NavMesh (check with NavMesh visualization)&#10;- [ ] Arrival threshold (1.5m) is reasonable for your scene scale&#10;- [ ] No obstacles blocking path to guard point&#10;- [ ] NavMeshAgent radius allows guard to reach point&#10;&#10;### Action triggers too often&#10;- [ ] StandGuardTimerBehaviour is being added to guard (check in inspector during play)&#10;- [ ] Cooldown duration is set correctly (15 seconds in LastStoodGuardSensor.cs)&#10;- [ ] Check console for cooldown logs&#10;&#10;### Guard stands at wrong location&#10;- [ ] Verify StandGuardPoint objects are positioned where you want&#10;- [ ] Check that objects are tagged correctly (not other objects with similar names)&#10;- [ ] Sensor finds nearest point - ensure this is the desired behavior&#10;&#10;##  Debugging Tools&#10;&#10;### Console Logs to Watch For&#10;Look for these logs during testing:&#10;```&#10;[StandGuardAction] Guard_01 starting - moving to guard point at (x, y, z)&#10;[StandGuardAction] Guard_01 arrived at guard point, starting 10s guard duty&#10;[StandGuardAction] Found angle points: AnglePoint_Left_1 and AnglePoint_Right_1&#10;[StandGuardAction] Guard_01 completed 10s guard duty&#10;[StandGuardAction] Guard_01 completed and started cooldown&#10;[StandGuardTimer] Guard_01 started cooldown at 123.45&#10;```&#10;&#10;### GOAP Graph Viewer&#10;1. Select guard during Play mode&#10;2. Open **Window → CrashKonijn → GOAP → Graph Viewer**&#10;3. Check if StandGuardGoal appears in the graph&#10;4. Check if StandGuardAction is being considered&#10;5. Look at condition values (should show difficulty, energy, etc.)&#10;&#10;### Manual Sensor Testing&#10;Add this to a test script to check sensor values:&#10;```csharp&#10;void Update() {&#10;    if (Input.GetKeyDown(KeyCode.T)) {&#10;        Debug.Log($&quot;Difficulty: {DifficultyTracker.GetDifficultyF() * 100}%&quot;);&#10;        &#10;        var timer = GetComponent&lt;StandGuardTimerBehaviour&gt;();&#10;        if (timer != null)&#10;            Debug.Log($&quot;Time since last guard: {timer.GetTimeSinceLastGuard()}s&quot;);&#10;            &#10;        var guardPoints = GameObject.FindGameObjectsWithTag(&quot;StandGuardPoint&quot;);&#10;        Debug.Log($&quot;Found {guardPoints.Length} guard points&quot;);&#10;        &#10;        var anglePoints = GameObject.FindGameObjectsWithTag(&quot;StandGuardAnglePoint&quot;);&#10;        Debug.Log($&quot;Found {anglePoints.Length} angle points&quot;);&#10;    }&#10;}&#10;```&#10;&#10;##  Expected Behavior Summary&#10;&#10;**When difficulty ≥75% and guard is near a guard point:**&#10;&#10;1. **Interrupt Patrol** - Guard stops patrolling immediately&#10;2. **Move to Point** - Guard walks to nearest StandGuardPoint&#10;3. **Stand Guard** - Guard stops and stands idle for 10 seconds&#10;4. **Rotate** - Guard slowly rotates between two angle points&#10;5. **Resume** - After 10 seconds, guard resumes patrol&#10;6. **Cooldown** - Guard cannot stand guard again for 15 seconds&#10;&#10;**Priority over other actions:**&#10;- StandGuard (0.5) &gt; Patrol (1.0) ✓ Will interrupt&#10;- StandGuard (0.5) &lt; Recharge (4.0) ✓ Won't interrupt low energy&#10;- StandGuard (0.5) &lt; Pursuit (0.3) ✓ Won't interrupt pursuit&#10;- StandGuard (0.5) &lt; Catch (0.1) ✓ Won't interrupt catch&#10;&#10;##  Files Reference&#10;&#10;All files are in: `Assets/Scripts/GOAP/`&#10;&#10;**WorldKeys/**&#10;- AtStandGuardPoint.cs&#10;- LastStoodGuard.cs&#10;- DDA/DifficultyWK.cs (existing)&#10;&#10;**TargetKeys/**&#10;- StandGuardTarget.cs&#10;&#10;**Sensors/**&#10;- AtStandGuardPointSensor.cs&#10;- LastStoodGuardSensor.cs&#10;- StandGuardTargetSensor.cs&#10;- DDA/DifficultySensor.cs (existing)&#10;&#10;**Behaviours/**&#10;- StandGuardTimerBehaviour.cs&#10;&#10;**Actions/**&#10;- StandGuardAction.cs&#10;&#10;**Goals/**&#10;- StandGuardGoal.cs (already existed)&#10;&#10;**Capabilities/**&#10;- StandGuardCapability.asset&#10;&#10;## ✨ Success Criteria&#10;&#10;Your setup is complete when:&#10;- [ ] No compilation errors in Unity&#10;- [ ] Tags exist and are applied to scene objects&#10;- [ ] StandGuardCapability.asset is in GuardAgentTypeFactory&#10;- [ ] At least one StandGuardPoint and two StandGuardAnglePoints exist&#10;- [ ] Guard interrupts patrol when conditions are met&#10;- [ ] Guard walks to guard point and stands for 10 seconds&#10;- [ ] Guard rotates smoothly between angle points&#10;- [ ] Guard resumes patrol after guard duty&#10;- [ ] Guard respects 15-second cooldown&#10;- [ ] No console errors during guard duty&#10;&#10;---&#10;&#10;**Need help?** Check the detailed guides:&#10;- **STANDGUARD_SETUP_GUIDE.md** - Full setup instructions&#10;- **STANDGUARD_ARCHITECTURE.md** - System architecture diagrams&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/GOAP/STANDGUARD_IMPLEMENTATION_SUMMARY.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/GOAP/STANDGUARD_IMPLEMENTATION_SUMMARY.md" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="# StandGuard Implementation - Complete Summary&#10;&#10;## Overview&#10;Successfully implemented a complete StandGuard Goal/Action pair for the GOAP system that allows guards to stand at designated points when difficulty is high (≥75%). The implementation includes all necessary WorldKeys, TargetKeys, Sensors, Behaviours, and Configuration.&#10;&#10;## Implementation Date&#10;November 21, 2025&#10;&#10;## Requirements Met&#10;&#10;### ✅ Action Selection Conditions&#10;- [x] **Difficulty ≥ 75** - Implemented via DifficultySensor reading DifficultyTracker&#10;- [x] **Within 5 meters of StandGuardPoint** - Implemented via AtStandGuardPointSensor&#10;- [x] **EnergySensor &gt; 0** - Reuses existing EnergySensor from RechargeCapability&#10;- [x] **LastStoodGuardSensor &gt; 15 seconds** - Implemented via LastStoodGuardSensor + StandGuardTimerBehaviour&#10;&#10;### ✅ Priority and Behavior&#10;- [x] **Higher priority than PatrolAction** - baseCost 0.5 vs 1.0 (will interrupt patrol)&#10;- [x] **Walk to nearest StandGuardPoint** - Implemented in StandGuardAction Phase 1&#10;- [x] **Stand for 10 seconds** - Implemented in StandGuardAction Phase 2&#10;- [x] **Rotate between 2 nearest angle points** - Finds 2 closest StandGuardAnglePoint objects and rotates&#10;- [x] **15-second cooldown** - Implemented via StandGuardTimerBehaviour&#10;&#10;## Files Created (11 total)&#10;&#10;### WorldKeys (3 files)&#10;Location: `Assets/Scripts/GOAP/WorldKeys/`&#10;&#10;1. **AtStandGuardPoint.cs**&#10;   - GUID: `AtStandGuardPoint-a1b2c3d4-e5f6-4a7b-8c9d-0e1f2a3b4c5d`&#10;   - Purpose: Tracks if guard is within 5m of any StandGuardPoint&#10;   - Type: Boolean (0/1)&#10;&#10;2. **LastStoodGuard.cs**&#10;   - GUID: `LastStoodGuard-b2c3d4e5-f6a7-4b8c-9d0e-1f2a3b4c5d6e`&#10;   - Purpose: Tracks seconds since last guard duty&#10;   - Type: Integer (seconds)&#10;&#10;3. **Difficulty.cs**&#10;   - GUID: `Difficulty-c3d4e5f6-a7b8-4c9d-0e1f-2a3b4c5d6e7f`&#10;   - Purpose: Tracks current difficulty percentage&#10;   - Type: Integer (0-100)&#10;&#10;### TargetKeys (1 file)&#10;Location: `Assets/Scripts/GOAP/TargetKeys/`&#10;&#10;4. **StandGuardTarget.cs**&#10;   - GUID: `StandGuardTarget-d4e5f6a7-b8c9-4d0e-1f2a-3b4c5d6e7f8a`&#10;   - Purpose: Target key for nearest StandGuardPoint position&#10;   - Type: PositionTarget (Vector3)&#10;&#10;### Sensors (4 files)&#10;Location: `Assets/Scripts/GOAP/Sensors/`&#10;&#10;5. **DifficultySensor.cs**&#10;   - GUID: `DifficultySensor-e5f6a7b8-c9d0-4e1f-2a3b-4c5d6e7f8a9b`&#10;   - Purpose: Reads difficulty from DifficultyTracker&#10;   - Output: Integer (0-100)&#10;   - WorldKey: Difficulty&#10;&#10;6. **AtStandGuardPointSensor.cs**&#10;   - GUID: `AtStandGuardPointSensor-f6a7b8c9-d0e1-4f2a-3b4c-5d6e7f8a9b0c`&#10;   - Purpose: Checks if guard within 5m of any StandGuardPoint&#10;   - Output: Boolean as integer (0/1)&#10;   - WorldKey: AtStandGuardPoint&#10;   - Method: FindGameObjectsWithTag(&quot;StandGuardPoint&quot;)&#10;&#10;7. **LastStoodGuardSensor.cs**&#10;   - GUID: `LastStoodGuardSensor-a7b8c9d0-e1f2-4a3b-4c5d-6e7f8a9b0c1d`&#10;   - Purpose: Returns seconds since last guard duty&#10;   - Output: Integer (seconds)&#10;   - WorldKey: LastStoodGuard&#10;   - Dependencies: StandGuardTimerBehaviour&#10;&#10;8. **StandGuardTargetSensor.cs**&#10;   - GUID: `StandGuardTargetSensor-b8c9d0e1-f2a3-4b4c-5d6e-7f8a9b0c1d2e`&#10;   - Purpose: Finds nearest StandGuardPoint position&#10;   - Output: PositionTarget (Vector3)&#10;   - TargetKey: StandGuardTarget&#10;   - Method: FindGameObjectsWithTag(&quot;StandGuardPoint&quot;), select nearest&#10;&#10;### Behaviours (1 file)&#10;Location: `Assets/Scripts/GOAP/Behaviours/`&#10;&#10;9. **StandGuardTimerBehaviour.cs**&#10;   - Purpose: Tracks cooldown timer per guard&#10;   - Methods:&#10;     - `StartCooldown()` - Called when guard completes duty&#10;     - `GetTimeSinceLastGuard()` - Returns seconds since last guard&#10;     - `IsCooldownComplete(duration)` - Checks if cooldown expired&#10;   - Lifecycle: Added dynamically to guard on first completion&#10;   - Default cooldown: 15 seconds&#10;&#10;### Capabilities (1 file)&#10;Location: `Assets/Scripts/GOAP/Capabilities/`&#10;&#10;10. **StandGuardCapability.asset**&#10;    - Purpose: Complete GOAP capability configuration&#10;    - Contains:&#10;      - Goal: StandGuardGoal (baseCost: 0.5)&#10;      - Action: StandGuardAction (baseCost: 0.5)&#10;      - WorldSensors: DifficultySensor, AtStandGuardPointSensor, LastStoodGuardSensor&#10;      - TargetSensors: StandGuardTargetSensor&#10;    - Goal Conditions:&#10;      - Difficulty ≥ 75&#10;      - AtStandGuardPoint ≤ 1 (within 5m)&#10;      - Energy &gt; 0&#10;      - LastStoodGuard &gt; 15&#10;    - Action Conditions (same as goal + IsAlert ≤ 0)&#10;&#10;### Documentation (3 files)&#10;Location: `Assets/Scripts/GOAP/`&#10;&#10;11. **STANDGUARD_SETUP_GUIDE.md**&#10;    - Comprehensive setup instructions&#10;    - File reference&#10;    - Unity setup steps&#10;    - Testing checklist&#10;    - Debugging tips&#10;    - Advanced configuration options&#10;&#10;12. **STANDGUARD_ARCHITECTURE.md**&#10;    - Component flow diagrams&#10;    - Condition evaluation flow&#10;    - Scene setup examples&#10;    - Priority system explanation&#10;    - Data flow diagrams&#10;    - State machine visualization&#10;&#10;13. **STANDGUARD_CHECKLIST.md**&#10;    - Quick setup checklist&#10;    - Troubleshooting guide&#10;    - Debugging tools&#10;    - Expected behavior summary&#10;    - Success criteria&#10;&#10;## Files Modified (1 file)&#10;&#10;### Actions (1 file)&#10;Location: `Assets/Scripts/GOAP/Actions/`&#10;&#10;**StandGuardAction.cs**&#10;- Status: Completely reimplemented&#10;- Previous: Template with empty methods&#10;- Current: Full implementation with two-phase execution&#10;- Features:&#10;  - Phase 1: Movement to guard point using NavMeshAgent&#10;  - Phase 2: Standing guard with rotation between angle points&#10;  - Arrival threshold: 1.5m&#10;  - Guard duration: 10 seconds&#10;  - Rotation speed: 2 rad/s&#10;  - Rotation switching threshold: 5 degrees&#10;  - Finds 2 nearest StandGuardAnglePoint objects dynamically&#10;  - Starts cooldown timer on completion&#10;  - Proper NavMeshAgent cleanup in End()&#10;  - Animation support (Walk, Idle)&#10;  - Audio support (PlayWalkLoop, StopWalkLoop)&#10;&#10;## Files Already Existing (1 file)&#10;&#10;### Goals (1 file)&#10;Location: `Assets/Scripts/GOAP/Goals/`&#10;&#10;**StandGuardGoal.cs**&#10;- GUID: `StandGuard-93d03afc-596a-4217-aeb8-e83412522118`&#10;- Status: Already existed in codebase&#10;- No modifications needed&#10;&#10;## Unity Tags Required (2 tags)&#10;&#10;1. **StandGuardPoint**&#10;   - Purpose: Marks positions where guards should stand&#10;   - Applied to: Empty GameObjects in scene&#10;&#10;2. **StandGuardAnglePoint**&#10;   - Purpose: Marks rotation target points for guards&#10;   - Applied to: Empty GameObjects near each StandGuardPoint&#10;   - Minimum: 2 per guard point&#10;&#10;## Integration Points&#10;&#10;### With Existing Systems&#10;&#10;1. **Difficulty System (DDA)**&#10;   - Uses: `DifficultyTracker.GetDifficultyF()`&#10;   - Conversion: 0.0-1.0 → 0-100 (percentage)&#10;   - Compatible with both dynamic and static difficulty modes&#10;&#10;2. **Energy System**&#10;   - Reuses: `Energy` WorldKey&#10;   - Reuses: `EnergySensor`&#10;   - Behavior: Guards won't stand guard if energy depleted&#10;   - Note: Standing guard does NOT consume energy&#10;&#10;3. **Alert System**&#10;   - Reuses: `IsAlert` WorldKey&#10;   - Behavior: Guards won't stand guard while in alert/pursuit mode&#10;&#10;4. **Patrol System**&#10;   - Priority: StandGuard (0.5) &gt; Patrol (1.0)&#10;   - Behavior: Will interrupt patrol when conditions met&#10;   - Resume: Guard resumes patrol after completing guard duty&#10;&#10;5. **Animation System**&#10;   - Uses: `GuardAnimation` component&#10;   - Animations: Walk (movement), Idle (guard duty)&#10;&#10;6. **Audio System**&#10;   - Uses: `ActionAudioBehaviour` component&#10;   - Audio: Walk loop (movement), stops on arrival&#10;&#10;7. **Navigation System**&#10;   - Uses: `NavMeshAgent` component&#10;   - Movement: Standard NavMesh pathfinding to guard point&#10;   - Rotation: Manual control during guard duty&#10;&#10;## Priority System&#10;&#10;Action priority hierarchy (lower baseCost = higher priority):&#10;```&#10;CatchAction      (0.1) - Highest&#10;PursuitAction    (0.3)&#10;StandGuardAction (0.5) ← NEW&#10;PatrolAction     (1.0)&#10;RechargeAction   (4.0) - Lowest&#10;```&#10;&#10;Result: StandGuard will interrupt Patrol but not Pursuit/Catch.&#10;&#10;## Configuration Constants&#10;&#10;### StandGuardAction.cs&#10;```csharp&#10;private const float GUARD_DURATION = 10f;        // Stand guard for 10 seconds&#10;private const float ARRIVAL_THRESHOLD = 1.5f;    // Distance to consider &quot;arrived&quot;&#10;private const float ROTATION_SPEED = 2f;         // Rotation speed in rad/s&#10;```&#10;&#10;### AtStandGuardPointSensor.cs&#10;```csharp&#10;private const float PROXIMITY_THRESHOLD = 5f;    // Within 5 meters&#10;```&#10;&#10;### LastStoodGuardSensor.cs&#10;```csharp&#10;private const float COOLDOWN_DURATION = 15f;     // 15 second cooldown&#10;```&#10;&#10;## Testing Status&#10;&#10;### ✅ Code Quality&#10;- All files compile without errors&#10;- Only minor warnings (namespace conventions)&#10;- Proper GUID generation for all GOAP components&#10;- Consistent naming conventions&#10;- Comprehensive debug logging&#10;&#10;### ⏳ Unity Testing Required&#10;User must complete Unity setup:&#10;1. Add tags to project&#10;2. Create scene objects (guard points, angle points)&#10;3. Add StandGuardCapability to GuardAgentTypeFactory&#10;4. Test in both static and dynamic difficulty modes&#10;5. Verify behavior matches requirements&#10;&#10;## Next Steps for User&#10;&#10;1. **Open Unity Editor**&#10;2. **Follow STANDGUARD_CHECKLIST.md** for setup steps&#10;3. **Create StandGuardPoint and StandGuardAnglePoint objects** in scene&#10;4. **Add StandGuardCapability.asset** to GuardAgentTypeFactory&#10;5. **Test with difficulty ≥75%**&#10;6. **Verify all behavior requirements**&#10;&#10;## Support Documentation&#10;&#10;Three comprehensive guides created:&#10;1. **STANDGUARD_SETUP_GUIDE.md** - Full implementation guide&#10;2. **STANDGUARD_ARCHITECTURE.md** - System architecture and diagrams&#10;3. **STANDGUARD_CHECKLIST.md** - Quick reference and troubleshooting&#10;&#10;## Technical Notes&#10;&#10;### GOAP Integration&#10;- Follows CrashKonijn GOAP v3 patterns&#10;- Uses LocalWorldSensorBase for world state&#10;- Uses LocalTargetSensorBase for target finding&#10;- Proper GoapId attributes on all components&#10;- Compatible with existing capability system&#10;&#10;### Performance Considerations&#10;- Sensors use `FindGameObjectsWithTag()` - cached results recommended for production&#10;- Rotation calculation per frame during guard duty - minimal overhead&#10;- Timer behaviour persists on guard - negligible memory impact&#10;&#10;### Extensibility&#10;- All constants are configurable&#10;- Easy to add additional conditions&#10;- Rotation behavior can be customized&#10;- Guard duration can be adjusted per instance if needed&#10;&#10;## Known Limitations&#10;&#10;1. **Angle Point Selection**: Finds 2 nearest points globally, not per guard point&#10;   - Workaround: Position angle points close to their respective guard points&#10;&#10;2. **NavMesh Requirement**: StandGuardPoints must be on or near NavMesh&#10;   - Workaround: Use NavMesh.SamplePosition in scene setup&#10;&#10;3. **Tag-based Finding**: Uses FindGameObjectsWithTag (not the most performant)&#10;   - Future: Consider caching or manager-based approach for production&#10;&#10;## Conclusion&#10;&#10;Complete implementation of StandGuard Goal/Action pair delivered with:&#10;- ✅ All required functionality&#10;- ✅ Proper GOAP integration&#10;- ✅ Comprehensive documentation&#10;- ✅ No compilation errors&#10;- ✅ Ready for Unity testing&#10;&#10;User can now proceed with Unity setup using the provided documentation.&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/GOAP/STANDGUARD_INDEX.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/GOAP/STANDGUARD_INDEX.md" />
              <option name="updatedContent" value="# StandGuard Implementation - Documentation Index&#10;&#10;##  Quick Navigation&#10;&#10;###  Getting Started&#10;**Start here if you're setting this up for the first time:**&#10;1. Read: [`STANDGUARD_QUICK_REFERENCE.md`](STANDGUARD_QUICK_REFERENCE.md) - 1-page overview&#10;2. Follow: [`STANDGUARD_CHECKLIST.md`](STANDGUARD_CHECKLIST.md) - Step-by-step setup&#10;3. Setup scene: [`STANDGUARD_SCENE_EXAMPLES.md`](STANDGUARD_SCENE_EXAMPLES.md) - Scene object positioning&#10;&#10;###  Complete Guides&#10;- [`STANDGUARD_SETUP_GUIDE.md`](STANDGUARD_SETUP_GUIDE.md) - Complete implementation guide with all details&#10;- [`STANDGUARD_ARCHITECTURE.md`](STANDGUARD_ARCHITECTURE.md) - System architecture, diagrams, and data flow&#10;- [`STANDGUARD_IMPLEMENTATION_SUMMARY.md`](STANDGUARD_IMPLEMENTATION_SUMMARY.md) - Technical summary and file reference&#10;&#10;###  Scene Setup&#10;- [`STANDGUARD_SCENE_EXAMPLES.md`](STANDGUARD_SCENE_EXAMPLES.md) - Visual examples and scene layout patterns&#10;&#10;---&#10;&#10;##  Document Descriptions&#10;&#10;### STANDGUARD_QUICK_REFERENCE.md&#10;**What it is:** Single-page quick reference card  &#10;**Best for:** Quick lookups, reminders, at-a-glance info  &#10;**Contains:**&#10;- 5-step setup guide&#10;- Condition requirements table&#10;- File list&#10;- Behavior flow diagram&#10;- Troubleshooting quick fixes&#10;- Console log examples&#10;&#10;**Read time:** 5 minutes  &#10;**Use when:** You need a quick answer or reminder&#10;&#10;---&#10;&#10;### STANDGUARD_CHECKLIST.md&#10;**What it is:** Interactive setup checklist  &#10;**Best for:** First-time setup, verification  &#10;**Contains:**&#10;- Pre-Unity steps (completed)&#10;- Unity setup checklist with checkboxes&#10;- Troubleshooting section&#10;- Debugging tools&#10;- Expected behavior list&#10;- Success criteria&#10;&#10;**Read time:** 10 minutes  &#10;**Use when:** Setting up for the first time or verifying setup&#10;&#10;---&#10;&#10;### STANDGUARD_SCENE_EXAMPLES.md&#10;**What it is:** Visual scene setup guide  &#10;**Best for:** Understanding how to position GameObjects  &#10;**Contains:**&#10;- 5 example scene layouts&#10;- ASCII diagrams of guard point configurations&#10;- Position guidelines&#10;- Unity hierarchy examples&#10;- Inspector configurations&#10;- Common patterns&#10;- Visual debug helper script&#10;&#10;**Read time:** 15 minutes  &#10;**Use when:** Creating guard points and angle points in your scene&#10;&#10;---&#10;&#10;### STANDGUARD_SETUP_GUIDE.md&#10;**What it is:** Complete implementation guide  &#10;**Best for:** Understanding the full system  &#10;**Contains:**&#10;- Files created overview&#10;- Unity setup steps detailed&#10;- Testing checklist&#10;- Debugging tips&#10;- Advanced configuration options&#10;- Integration details with existing systems&#10;- Performance considerations&#10;&#10;**Read time:** 20 minutes  &#10;**Use when:** You need complete understanding or advanced configuration&#10;&#10;---&#10;&#10;### STANDGUARD_ARCHITECTURE.md&#10;**What it is:** System architecture documentation  &#10;**Best for:** Understanding how components work together  &#10;**Contains:**&#10;- Component flow diagrams&#10;- Condition evaluation flow&#10;- Scene setup diagrams&#10;- Priority system explanation&#10;- Data flow diagrams&#10;- State machine visualization&#10;- Sensor layer details&#10;&#10;**Read time:** 20 minutes  &#10;**Use when:** Debugging, modifying, or extending the system&#10;&#10;---&#10;&#10;### STANDGUARD_IMPLEMENTATION_SUMMARY.md&#10;**What it is:** Technical reference and file catalog  &#10;**Best for:** Finding specific files, GUIDs, technical details  &#10;**Contains:**&#10;- Complete file list with GUIDs&#10;- File purpose descriptions&#10;- Integration points&#10;- Configuration constants&#10;- Testing status&#10;- Known limitations&#10;- Extensibility notes&#10;&#10;**Read time:** 15 minutes  &#10;**Use when:** Looking up technical details or file locations&#10;&#10;---&#10;&#10;##  Recommended Reading Paths&#10;&#10;### Path 1: Quick Setup (30 minutes)&#10;For those who want to get it working ASAP:&#10;1. [`STANDGUARD_QUICK_REFERENCE.md`](STANDGUARD_QUICK_REFERENCE.md) - Understand what it does&#10;2. [`STANDGUARD_CHECKLIST.md`](STANDGUARD_CHECKLIST.md) - Follow the steps&#10;3. [`STANDGUARD_SCENE_EXAMPLES.md`](STANDGUARD_SCENE_EXAMPLES.md) - Create scene objects&#10;4. Test in Unity&#10;&#10;### Path 2: Thorough Understanding (60 minutes)&#10;For those who want to understand the system fully:&#10;1. [`STANDGUARD_IMPLEMENTATION_SUMMARY.md`](STANDGUARD_IMPLEMENTATION_SUMMARY.md) - Overview&#10;2. [`STANDGUARD_ARCHITECTURE.md`](STANDGUARD_ARCHITECTURE.md) - How it works&#10;3. [`STANDGUARD_SETUP_GUIDE.md`](STANDGUARD_SETUP_GUIDE.md) - Setup details&#10;4. [`STANDGUARD_SCENE_EXAMPLES.md`](STANDGUARD_SCENE_EXAMPLES.md) - Scene setup&#10;5. [`STANDGUARD_CHECKLIST.md`](STANDGUARD_CHECKLIST.md) - Execute setup&#10;&#10;### Path 3: Troubleshooting&#10;When something isn't working:&#10;1. [`STANDGUARD_CHECKLIST.md`](STANDGUARD_CHECKLIST.md) - Check troubleshooting section&#10;2. [`STANDGUARD_QUICK_REFERENCE.md`](STANDGUARD_QUICK_REFERENCE.md) - Verify conditions&#10;3. [`STANDGUARD_ARCHITECTURE.md`](STANDGUARD_ARCHITECTURE.md) - Understand data flow&#10;4. Console logs (check for `[StandGuardAction]` messages)&#10;&#10;### Path 4: Modification/Extension&#10;When you want to modify the system:&#10;1. [`STANDGUARD_ARCHITECTURE.md`](STANDGUARD_ARCHITECTURE.md) - Understand structure&#10;2. [`STANDGUARD_IMPLEMENTATION_SUMMARY.md`](STANDGUARD_IMPLEMENTATION_SUMMARY.md) - Find files&#10;3. [`STANDGUARD_SETUP_GUIDE.md`](STANDGUARD_SETUP_GUIDE.md) - Configuration options&#10;4. Modify code&#10;&#10;---&#10;&#10;## ️ File Organization&#10;&#10;```&#10;Assets/Scripts/GOAP/&#10;│&#10;├──  Documentation (This folder)&#10;│   ├── STANDGUARD_QUICK_REFERENCE.md          (Quick reference)&#10;│   ├── STANDGUARD_CHECKLIST.md                (Setup checklist)&#10;│   ├── STANDGUARD_SCENE_EXAMPLES.md           (Scene layouts)&#10;│   ├── STANDGUARD_SETUP_GUIDE.md              (Complete guide)&#10;│   ├── STANDGUARD_ARCHITECTURE.md             (System architecture)&#10;│   ├── STANDGUARD_IMPLEMENTATION_SUMMARY.md   (Technical reference)&#10;│   └── STANDGUARD_INDEX.md                    (This file)&#10;│&#10;├──  WorldKeys/&#10;│   ├── AtStandGuardPoint.cs&#10;│   ├── LastStoodGuard.cs&#10;│   └── DDA/&#10;│       └── DifficultyWK.cs (existing)&#10;│&#10;├──  TargetKeys/&#10;│   └── StandGuardTarget.cs&#10;│&#10;├──  Sensors/&#10;│   ├── AtStandGuardPointSensor.cs&#10;│   ├── LastStoodGuardSensor.cs&#10;│   ├── StandGuardTargetSensor.cs&#10;│   └── DDA/&#10;│       └── DifficultySensor.cs (existing)&#10;│&#10;├──  Behaviours/&#10;│   └── StandGuardTimerBehaviour.cs&#10;│&#10;├──  Actions/&#10;│   └── StandGuardAction.cs&#10;│&#10;├──  Goals/&#10;│   └── StandGuardGoal.cs (existing)&#10;│&#10;└──  Capabilities/&#10;    └── StandGuardCapability.asset&#10;```&#10;&#10;---&#10;&#10;##  Finding Information Quickly&#10;&#10;### &quot;How do I set it up?&quot;&#10;→ [`STANDGUARD_CHECKLIST.md`](STANDGUARD_CHECKLIST.md)&#10;&#10;### &quot;What does it do?&quot;&#10;→ [`STANDGUARD_QUICK_REFERENCE.md`](STANDGUARD_QUICK_REFERENCE.md)&#10;&#10;### &quot;How do I position the guard points?&quot;&#10;→ [`STANDGUARD_SCENE_EXAMPLES.md`](STANDGUARD_SCENE_EXAMPLES.md)&#10;&#10;### &quot;It's not working, what's wrong?&quot;&#10;→ [`STANDGUARD_CHECKLIST.md`](STANDGUARD_CHECKLIST.md) - Troubleshooting section&#10;&#10;### &quot;What files were created?&quot;&#10;→ [`STANDGUARD_IMPLEMENTATION_SUMMARY.md`](STANDGUARD_IMPLEMENTATION_SUMMARY.md) - Files Created section&#10;&#10;### &quot;How does it integrate with my existing code?&quot;&#10;→ [`STANDGUARD_ARCHITECTURE.md`](STANDGUARD_ARCHITECTURE.md) - Integration Points section&#10;&#10;### &quot;What are the configurable values?&quot;&#10;→ [`STANDGUARD_SETUP_GUIDE.md`](STANDGUARD_SETUP_GUIDE.md) - Advanced Configuration section&#10;&#10;### &quot;How do I modify the guard duration?&quot;&#10;→ [`STANDGUARD_SETUP_GUIDE.md`](STANDGUARD_SETUP_GUIDE.md) - Advanced Configuration section&#10;&#10;### &quot;What GUIDs do I need?&quot;&#10;→ [`STANDGUARD_IMPLEMENTATION_SUMMARY.md`](STANDGUARD_IMPLEMENTATION_SUMMARY.md) - Files Created section&#10;&#10;### &quot;How do I debug it?&quot;&#10;→ [`STANDGUARD_CHECKLIST.md`](STANDGUARD_CHECKLIST.md) - Debugging Tools section&#10;&#10;---&#10;&#10;##  Document Statistics&#10;&#10;| Document | Pages | Read Time | Complexity |&#10;|----------|-------|-----------|------------|&#10;| Quick Reference | 1-2 | 5 min | ⭐ Easy |&#10;| Checklist | 3-4 | 10 min | ⭐ Easy |&#10;| Scene Examples | 5-6 | 15 min | ⭐⭐ Medium |&#10;| Setup Guide | 8-10 | 20 min | ⭐⭐ Medium |&#10;| Architecture | 8-10 | 20 min | ⭐⭐⭐ Advanced |&#10;| Implementation Summary | 6-8 | 15 min | ⭐⭐⭐ Advanced |&#10;&#10;---&#10;&#10;##  Tips for Using Documentation&#10;&#10;1. **Start with Quick Reference** - Get familiar with the system first&#10;2. **Use Checklist for Setup** - Don't skip steps&#10;3. **Refer to Scene Examples** - Visual guidance is invaluable&#10;4. **Keep Quick Reference Handy** - For testing and debugging&#10;5. **Read Architecture if Modifying** - Understand before changing&#10;&#10;---&#10;&#10;## ✅ Completion Checklist&#10;&#10;Documentation:&#10;- [x] Quick reference created&#10;- [x] Setup checklist created&#10;- [x] Scene examples created&#10;- [x] Setup guide created&#10;- [x] Architecture documentation created&#10;- [x] Implementation summary created&#10;- [x] Index created (this file)&#10;&#10;Code:&#10;- [x] All scripts created&#10;- [x] All sensors implemented&#10;- [x] All world keys created&#10;- [x] Capability configured&#10;- [x] No compilation errors&#10;&#10;Ready for Unity:&#10;- [ ] Tags added to Unity project&#10;- [ ] Scene objects created&#10;- [ ] Capability added to GOAP config&#10;- [ ] Tested in play mode&#10;&#10;---&#10;&#10;##  Getting Help&#10;&#10;If you're stuck:&#10;1. Check [`STANDGUARD_CHECKLIST.md`](STANDGUARD_CHECKLIST.md) troubleshooting section&#10;2. Review console logs for error messages&#10;3. Verify all conditions are met (difficulty, distance, energy, cooldown)&#10;4. Check GOAP Graph Viewer in Unity&#10;5. Review [`STANDGUARD_ARCHITECTURE.md`](STANDGUARD_ARCHITECTURE.md) for understanding&#10;&#10;---&#10;&#10;**All documentation is located in:** `Assets/Scripts/GOAP/`&#10;&#10;**Last Updated:** November 21, 2025&#10;&#10;**Status:** ✅ Complete and ready for use&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/GOAP/STANDGUARD_QUICK_REFERENCE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/GOAP/STANDGUARD_QUICK_REFERENCE.md" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="# StandGuard - Quick Reference Card&#10;&#10;##  What It Does&#10;Guards stand at designated points for 10 seconds when difficulty is high, rotating to watch between two angle points.&#10;&#10;##  Quick Setup (5 Steps)&#10;&#10;### 1️⃣ Add Tags (Unity Editor)&#10;```&#10;Edit → Project Settings → Tags and Layers&#10;Add: &quot;StandGuardPoint&quot;&#10;Add: &quot;StandGuardAnglePoint&quot;&#10;```&#10;&#10;### 2️⃣ Create Scene Objects&#10;```&#10;Create Empty GameObject → Tag as &quot;StandGuardPoint&quot; → Position where guard should stand&#10;Create 2 Empty GameObjects → Tag as &quot;StandGuardAnglePoint&quot; → Position to define guard's viewing arc&#10;```&#10;&#10;### 3️⃣ Add Capability&#10;```&#10;Find GameObject with GoapBehaviour&#10;→ GuardAgentTypeFactory component&#10;→ Capabilities list&#10;→ Add: StandGuardCapability.asset&#10;```&#10;&#10;### 4️⃣ Test Setup&#10;```&#10;Set Difficulty ≥ 75%&#10;Move guard within 5m of StandGuardPoint&#10;Guard should interrupt patrol and walk to point&#10;```&#10;&#10;### 5️⃣ Verify Behavior&#10;```&#10;✓ Guard walks to point&#10;✓ Guard stands for 10 seconds&#10;✓ Guard rotates between angle points&#10;✓ Guard resumes patrol&#10;✓ 15-second cooldown before next guard duty&#10;```&#10;&#10;##  Conditions (All Must Be Met)&#10;&#10;| Condition | Requirement | Sensor |&#10;|-----------|-------------|--------|&#10;| **Difficulty** | ≥ 75% | DifficultySensor |&#10;| **Distance** | ≤ 5 meters from guard point | AtStandGuardPointSensor |&#10;| **Energy** | &gt; 0 | EnergySensor (existing) |&#10;| **Cooldown** | &gt; 15 seconds since last guard | LastStoodGuardSensor |&#10;| **Alert** | Not in alert mode | AlertSensor (existing) |&#10;&#10;##  Files Created&#10;&#10;| Category | File | Purpose |&#10;|----------|------|---------|&#10;| **WorldKeys** | AtStandGuardPoint.cs | Within 5m of guard point? |&#10;| | LastStoodGuard.cs | Seconds since last guard |&#10;| | DDA/DifficultyWK.cs* | Tracks difficulty 0-100 (existing) |&#10;| **TargetKeys** | StandGuardTarget.cs | Nearest guard point position |&#10;| **Sensors** | AtStandGuardPointSensor.cs | Proximity check |&#10;| | LastStoodGuardSensor.cs | Timer check |&#10;| | StandGuardTargetSensor.cs | Find nearest point |&#10;| | DDA/DifficultySensor.cs* | Reads DifficultyTracker (existing) |&#10;| **Behaviours** | StandGuardTimerBehaviour.cs | Cooldown timer per guard |&#10;| **Capabilities** | StandGuardCapability.asset | GOAP config |&#10;&#10;*Already existed in codebase&#10;&#10;##  Behavior Flow&#10;&#10;```&#10;PATROL (default)&#10;    ↓ (Conditions met)&#10;MOVE TO GUARD POINT&#10;    • Walk animation&#10;    • NavMeshAgent pathfinding&#10;    ↓ (Arrive within 1.5m)&#10;STAND GUARD (10 seconds)&#10;    • Idle animation&#10;    • Rotate between angle points&#10;    • Smooth Slerp rotation&#10;    ↓ (10 seconds complete)&#10;START COOLDOWN (15 seconds)&#10;    ↓&#10;RESUME PATROL&#10;    ↓ (After 15s + conditions met)&#10;[Can guard again]&#10;```&#10;&#10;## ⚙️ Configurable Constants&#10;&#10;| Constant | Value | Location | Description |&#10;|----------|-------|----------|-------------|&#10;| GUARD_DURATION | 10s | StandGuardAction.cs | How long to stand guard |&#10;| COOLDOWN_DURATION | 15s | LastStoodGuardSensor.cs | Time before can guard again |&#10;| PROXIMITY_THRESHOLD | 5m | AtStandGuardPointSensor.cs | Distance to enable action |&#10;| ARRIVAL_THRESHOLD | 1.5m | StandGuardAction.cs | Distance to stop moving |&#10;| ROTATION_SPEED | 2 rad/s | StandGuardAction.cs | How fast to rotate |&#10;| DIFFICULTY_THRESHOLD | 75 | StandGuardCapability.asset | Min difficulty % |&#10;&#10;##  Priority vs Other Actions&#10;&#10;```&#10;Priority: Lower baseCost = Higher Priority&#10;┌─────────────────────────────────────┐&#10;│ CatchAction      (0.1) ← HIGHEST    │&#10;│ PursuitAction    (0.3)              │&#10;│ StandGuardAction (0.5) ← THIS       │&#10;│ PatrolAction     (1.0)              │&#10;│ RechargeAction   (4.0) ← LOWEST     │&#10;└─────────────────────────────────────┘&#10;&#10;Result: Will interrupt Patrol, but not Pursuit/Catch&#10;```&#10;&#10;##  Quick Troubleshooting&#10;&#10;| Problem | Solution |&#10;|---------|----------|&#10;| Action never triggers | Check difficulty ≥75, within 5m, tags correct |&#10;| Guard doesn't rotate | Need 2+ StandGuardAnglePoint objects |&#10;| Guard gets stuck | Ensure guard point is on NavMesh |&#10;| Action triggers too often | Check cooldown timer logs in console |&#10;| Compilation errors | Verify all files created, restart Unity |&#10;&#10;##  Console Logs&#10;&#10;Look for these during testing:&#10;```&#10;[StandGuardAction] Guard_01 starting - moving to guard point at (x,y,z)&#10;[StandGuardAction] Guard_01 arrived at guard point, starting 10s guard duty&#10;[StandGuardAction] Found angle points: AnglePoint_Left and AnglePoint_Right&#10;[StandGuardAction] Guard_01 completed 10s guard duty&#10;[StandGuardTimer] Guard_01 started cooldown at 123.45&#10;```&#10;&#10;##  Documentation Files&#10;&#10;| File | Purpose |&#10;|------|---------|&#10;| **STANDGUARD_CHECKLIST.md** | Step-by-step setup checklist |&#10;| **STANDGUARD_SETUP_GUIDE.md** | Complete implementation guide |&#10;| **STANDGUARD_ARCHITECTURE.md** | System architecture diagrams |&#10;| **STANDGUARD_IMPLEMENTATION_SUMMARY.md** | Full technical summary |&#10;&#10;##  Example Scene Setup&#10;&#10;```&#10;Hallway Scene&#10;├── GuardPoint_Entrance&#10;│   └── Tag: StandGuardPoint&#10;├── AnglePoint_Left&#10;│   └── Tag: StandGuardAnglePoint&#10;├── AnglePoint_Right&#10;│   └── Tag: StandGuardAnglePoint&#10;└── Guard_01&#10;    └── Will patrol normally, then stand at GuardPoint_Entrance&#10;        when difficulty reaches 75%&#10;```&#10;&#10;**Positioning Tip:**&#10;```&#10;     AngleLeft&#10;          |&#10;          |&#10;          ▼&#10;     GuardPoint ──────► AngleRight&#10;          ▲&#10;     (Guard rotates head between these angles)&#10;```&#10;&#10;## ✅ Success Checklist&#10;&#10;Quick test to verify everything works:&#10;- [ ] No compilation errors&#10;- [ ] Tags created&#10;- [ ] Scene objects created and tagged&#10;- [ ] Capability added to GuardAgentTypeFactory&#10;- [ ] Difficulty set to 75%+&#10;- [ ] Guard within 5m of guard point&#10;- [ ] Guard interrupts patrol&#10;- [ ] Guard walks to point&#10;- [ ] Guard stands for 10 seconds&#10;- [ ] Guard rotates smoothly&#10;- [ ] Guard resumes patrol&#10;- [ ] Cooldown prevents immediate repeat&#10;&#10;---&#10;&#10;**Need More Detail?** See full documentation in:&#10;- `STANDGUARD_SETUP_GUIDE.md`&#10;- `STANDGUARD_ARCHITECTURE.md`&#10;- `STANDGUARD_CHECKLIST.md`&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/GOAP/STANDGUARD_SCENE_EXAMPLES.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/GOAP/STANDGUARD_SCENE_EXAMPLES.md" />
              <option name="updatedContent" value="# StandGuard Scene Setup Examples&#10;&#10;## Example 1: Single Guard Point at Hallway Intersection&#10;&#10;```&#10;                    North Hallway&#10;                         │&#10;                         │&#10;                    [AnglePoint_N]&#10;                         │&#10;                         │&#10;    West Hall ──────────[●]──────────── East Hall&#10;                    GuardPoint_1&#10;                         │&#10;                         │&#10;                    [AnglePoint_S]&#10;                         │&#10;                         │&#10;                    South Hallway&#10;&#10;● = Guard standing position&#10;```&#10;&#10;**Setup:**&#10;1. Empty GameObject at intersection → Tag: &quot;StandGuardPoint&quot;&#10;2. Empty GameObject 3-5m north → Tag: &quot;StandGuardAnglePoint&quot;&#10;3. Empty GameObject 3-5m south → Tag: &quot;StandGuardAnglePoint&quot;&#10;&#10;**Result:** Guard will rotate to look north and south, watching both hallways.&#10;&#10;---&#10;&#10;## Example 2: Guard Point Watching Doorway&#10;&#10;```&#10;         ┌─────────────────────┐&#10;         │                     │&#10;         │      Room           │&#10;         │                     │&#10;         │                     │&#10;         └──────[Door]─────────┘&#10;                  │&#10;                  │&#10;            [AngleLeft]&#10;                  │&#10;            [GuardPoint]───────► [AngleRight]&#10;                  │&#10;                  │&#10;              Hallway&#10;```&#10;&#10;**Setup:**&#10;1. GuardPoint positioned in hallway facing door&#10;2. AngleLeft points at left side of doorway&#10;3. AngleRight points at right side of doorway&#10;&#10;**Result:** Guard watches doorway, scanning left to right.&#10;&#10;---&#10;&#10;## Example 3: Multiple Guard Points in Large Area&#10;&#10;```&#10;Museum Gallery Layout:&#10;&#10;    [Painting 1]              [Painting 2]&#10;         │                         │&#10;    [AngleL1]                 [AngleL2]&#10;         │                         │&#10;    [GuardPt1]                [GuardPt2]&#10;         │                         │&#10;    [AngleR1]                 [AngleR2]&#10;         │                         │&#10;         └──────────┬──────────────┘&#10;                    │&#10;              [Entrance]&#10;              &#10;    [Painting 3]              [Painting 4]&#10;         │                         │&#10;    [AngleL3]                 [AngleL3]&#10;         │                         │&#10;    [GuardPt3]                [GuardPt4]&#10;         │                         │&#10;    [AngleR3]                 [AngleR4]&#10;```&#10;&#10;**Setup:**&#10;- 4 guard points near valuable paintings&#10;- Each guard point has 2 angle points positioned to watch the painting&#10;- Guards will patrol normally, then when difficulty ≥75%, nearest guard will stand at closest point&#10;&#10;**Result:** Dynamic guard allocation - guards automatically choose nearest available point.&#10;&#10;---&#10;&#10;## Example 4: Narrow Corridor Guard&#10;&#10;```&#10;    ┌──────────────────────────────────┐&#10;    │                                  │&#10;    │    [AngleBack]                   │&#10;    │         │                        │&#10;    │    [GuardPoint]                  │&#10;    │         │                        │&#10;    │    [AngleFront]                  │&#10;    │                                  │&#10;    └──────────────────────────────────┘&#10;         Long Narrow Hallway&#10;```&#10;&#10;**Setup:**&#10;- Guard point in middle of long corridor&#10;- One angle point ahead (front)&#10;- One angle point behind (back)&#10;&#10;**Result:** Guard watches both ends of corridor, perfect for chokepoints.&#10;&#10;---&#10;&#10;## Example 5: Corner Guard (Wide Arc)&#10;&#10;```&#10;                Wall&#10;                 │&#10;                 │&#10;    [AngleLeft]──┘&#10;         │&#10;         │&#10;    [GuardPoint]&#10;         │&#10;         │&#10;         └──[AngleRight]&#10;                │&#10;               Wall&#10;```&#10;&#10;**Setup:**&#10;- Guard point at corner junction&#10;- Angle points positioned at 90° arc&#10;- Covers two perpendicular corridors&#10;&#10;**Result:** Guard scans around corner, watching both directions.&#10;&#10;---&#10;&#10;## Position Guidelines&#10;&#10;### Guard Point Positioning&#10;✅ **Good Locations:**&#10;- Intersections and junctions&#10;- Near valuable objects/objectives&#10;- Chokepoints and doorways&#10;- Strategic vantage points&#10;- On NavMesh or close to it&#10;&#10;❌ **Avoid:**&#10;- Dead-end corners (no tactical value)&#10;- Off NavMesh (guard can't reach)&#10;- Too close to obstacles&#10;- Overlapping with patrol waypoints&#10;&#10;### Angle Point Positioning&#10;&#10;**Distance from Guard Point:**&#10;- Minimum: 2 meters&#10;- Recommended: 3-5 meters&#10;- Maximum: No limit, but practical is 5-10 meters&#10;&#10;**Angular Separation:**&#10;- Narrow watch (focused): 30-60° between points&#10;- Normal watch: 60-90° between points&#10;- Wide watch (surveillance): 90-180° between points&#10;&#10;**Height:**&#10;- Keep at same Y-level as guard point&#10;- Guard only rotates horizontally (yaw)&#10;&#10;---&#10;&#10;## Unity Hierarchy Example&#10;&#10;```&#10;Scene&#10;├── Environment&#10;│   ├── GuardPoints&#10;│   │   ├── GP_Entrance&#10;│   │   │   └── Tag: &quot;StandGuardPoint&quot;&#10;│   │   ├── GP_Gallery&#10;│   │   │   └── Tag: &quot;StandGuardPoint&quot;&#10;│   │   └── GP_Corridor&#10;│   │       └── Tag: &quot;StandGuardPoint&quot;&#10;│   │&#10;│   └── AnglePoints&#10;│       ├── AP_Entrance_Left&#10;│       │   └── Tag: &quot;StandGuardAnglePoint&quot;&#10;│       ├── AP_Entrance_Right&#10;│       │   └── Tag: &quot;StandGuardAnglePoint&quot;&#10;│       ├── AP_Gallery_Left&#10;│       │   └── Tag: &quot;StandGuardAnglePoint&quot;&#10;│       ├── AP_Gallery_Right&#10;│       │   └── Tag: &quot;StandGuardAnglePoint&quot;&#10;│       ├── AP_Corridor_Front&#10;│       │   └── Tag: &quot;StandGuardAnglePoint&quot;&#10;│       └── AP_Corridor_Back&#10;│           └── Tag: &quot;StandGuardAnglePoint&quot;&#10;│&#10;├── Guards&#10;│   ├── Guard_01&#10;│   └── Guard_02&#10;│&#10;└── GOAP_Manager&#10;    └── GoapBehaviour (with GuardAgentTypeFactory)&#10;```&#10;&#10;---&#10;&#10;## Inspector Configuration&#10;&#10;### Guard Point GameObject&#10;```&#10;Inspector:&#10;- Transform: Position at guard location&#10;- Tag: &quot;StandGuardPoint&quot;&#10;- Layer: Default&#10;- (No components needed)&#10;```&#10;&#10;### Angle Point GameObject&#10;```&#10;Inspector:&#10;- Transform: Position to define guard's view direction&#10;- Tag: &quot;StandGuardAnglePoint&quot;&#10;- Layer: Default&#10;- (No components needed)&#10;```&#10;&#10;---&#10;&#10;## Testing Your Setup&#10;&#10;### Quick Test in Scene View&#10;1. Place guard point (red cube in scene)&#10;2. Place 2 angle points (blue cubes)&#10;3. Draw imaginary lines from guard point to each angle point&#10;4. Guard will rotate head between these lines&#10;&#10;### Visual Debug Helper (Optional)&#10;Add this script to test your setup:&#10;&#10;```csharp&#10;using UnityEngine;&#10;&#10;public class GuardPointVisualizer : MonoBehaviour&#10;{&#10;    void OnDrawGizmos()&#10;    {&#10;        if (CompareTag(&quot;StandGuardPoint&quot;))&#10;        {&#10;            Gizmos.color = Color.red;&#10;            Gizmos.DrawWireSphere(transform.position, 0.5f);&#10;            Gizmos.DrawWireSphere(transform.position, 5f); // Proximity range&#10;            &#10;            // Find angle points&#10;            var anglePoints = GameObject.FindGameObjectsWithTag(&quot;StandGuardAnglePoint&quot;);&#10;            Gizmos.color = Color.yellow;&#10;            foreach (var point in anglePoints)&#10;            {&#10;                if (Vector3.Distance(transform.position, point.transform.position) &lt; 10f)&#10;                {&#10;                    Gizmos.DrawLine(transform.position, point.transform.position);&#10;                }&#10;            }&#10;        }&#10;        &#10;        if (CompareTag(&quot;StandGuardAnglePoint&quot;))&#10;        {&#10;            Gizmos.color = Color.blue;&#10;            Gizmos.DrawWireSphere(transform.position, 0.3f);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;Attach to guard points and angle points to see connections in Scene view.&#10;&#10;---&#10;&#10;## Pro Tips&#10;&#10;### 1. Naming Convention&#10;```&#10;GuardPoint_Location_01&#10;AnglePoint_Location_Direction&#10;```&#10;Example:&#10;- GuardPoint_Entrance_01&#10;- AnglePoint_Entrance_Left&#10;- AnglePoint_Entrance_Right&#10;&#10;### 2. Use Empty Parent Objects&#10;```&#10;GuardSystem_Entrance&#10;├── GuardPoint_Entrance&#10;├── AnglePoint_Entrance_Left&#10;└── AnglePoint_Entrance_Right&#10;```&#10;Makes organization easier!&#10;&#10;### 3. Reusable Prefabs&#10;Create a prefab with guard point + 2 angle points pre-configured. Drag and drop into scene.&#10;&#10;### 4. Level Design Integration&#10;- Add guard points during level design&#10;- Position them at strategic locations&#10;- Consider player visibility and approach paths&#10;- Balance coverage vs. exploitability&#10;&#10;### 5. Testing Workflow&#10;1. Create one guard point with angle points&#10;2. Test with one guard&#10;3. Adjust timing/rotation as needed&#10;4. Duplicate and position for other locations&#10;&#10;---&#10;&#10;## Common Patterns&#10;&#10;### Doorway Watcher&#10;```&#10;Guard faces door, rotates ±45° to scan&#10;Angle points: Left/Right of doorframe&#10;Use case: Entrance security&#10;```&#10;&#10;### Hallway Patroller + Guard&#10;```&#10;Patrol route with guard point in middle&#10;When difficulty high, guard stops and watches both ends&#10;Use case: Long corridors&#10;```&#10;&#10;### Room Center Guard&#10;```&#10;Guard in center, 4 angle points at room corners&#10;Creates 360° surveillance effect (finds 2 nearest)&#10;Use case: Large open rooms&#10;```&#10;&#10;### Stairway Watcher&#10;```&#10;Guard at top/bottom of stairs&#10;Angle points: Up/Down the stairway&#10;Use case: Vertical chokepoints&#10;```&#10;&#10;---&#10;&#10;## Troubleshooting Scene Setup&#10;&#10;| Problem | Solution |&#10;|---------|----------|&#10;| Guard doesn't find point | Check tag spelling (case-sensitive) |&#10;| Guard doesn't rotate | Need at least 2 angle points near guard point |&#10;| Guard rotates wrong direction | Reposition angle points |&#10;| Guard walks but doesn't stop | Guard point might be off NavMesh |&#10;| Guard rotates 360° | Angle points are at same position |&#10;&#10;---&#10;&#10;## Final Checklist&#10;&#10;Scene Setup:&#10;- [ ] At least one GameObject tagged &quot;StandGuardPoint&quot;&#10;- [ ] At least two GameObjects tagged &quot;StandGuardAnglePoint&quot;&#10;- [ ] Guard points are on or near NavMesh&#10;- [ ] Angle points are positioned 3-5m from guard point&#10;- [ ] Angle points define reasonable viewing arc&#10;- [ ] Named clearly for organization&#10;- [ ] Tested with one guard first&#10;&#10;Unity Tags:&#10;- [ ] &quot;StandGuardPoint&quot; tag exists&#10;- [ ] &quot;StandGuardAnglePoint&quot; tag exists&#10;&#10;Capability:&#10;- [ ] StandGuardCapability.asset added to GuardAgentTypeFactory&#10;&#10;Ready to test!&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/GOAP/STANDGUARD_SETUP_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/GOAP/STANDGUARD_SETUP_GUIDE.md" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="# StandGuard Action Setup Guide&#10;&#10;## Overview&#10;The StandGuard action allows guards to stand at designated guard points when difficulty is high (≥75%). Guards will move to the nearest StandGuardPoint, remain there for 10 seconds while slowly rotating between two angle points, then have a 15-second cooldown before they can guard again.&#10;&#10;## Files Created&#10;&#10;### WorldKeys (C:\Users\Soya\Documents\Dev\AAU\MED7\DOAP-Difficulty-Oriented-Action-Planning\Assets\Scripts\GOAP\WorldKeys\)&#10;1. **AtStandGuardPoint.cs** - Tracks if guard is within 5m of a StandGuardPoint&#10;2. **LastStoodGuard.cs** - Tracks time (in seconds) since last guard duty&#10;3. **Difficulty.cs** - Tracks current difficulty percentage (0-100)&#10;&#10;### TargetKeys (C:\Users\Soya\Documents\Dev\AAU\MED7\DOAP-Difficulty-Oriented-Action-Planning\Assets\Scripts\GOAP\TargetKeys\)&#10;1. **StandGuardTarget.cs** - Target key for the nearest StandGuardPoint&#10;&#10;### Sensors (C:\Users\Soya\Documents\Dev\AAU\MED7\DOAP-Difficulty-Oriented-Action-Planning\Assets\Scripts\GOAP\Sensors\)&#10;1. **DifficultySensor.cs** - Reads difficulty from DifficultyTracker (0-100)&#10;2. **AtStandGuardPointSensor.cs** - Checks if guard is within 5m of any StandGuardPoint&#10;3. **LastStoodGuardSensor.cs** - Returns seconds since last guard duty&#10;4. **StandGuardTargetSensor.cs** - Finds nearest StandGuardPoint position&#10;&#10;### Behaviours (C:\Users\Soya\Documents\Dev\AAU\MED7\DOAP-Difficulty-Oriented-Action-Planning\Assets\Scripts\GOAP\Behaviours\)&#10;1. **StandGuardTimerBehaviour.cs** - Component that tracks cooldown timer per guard&#10;&#10;### Action (C:\Users\Soya\Documents\Dev\AAU\MED7\DOAP-Difficulty-Oriented-Action-Planning\Assets\Scripts\GOAP\Actions\)&#10;1. **StandGuardAction.cs** - Main action implementation (UPDATED)&#10;&#10;### Capability (C:\Users\Soya\Documents\Dev\AAU\MED7\DOAP-Difficulty-Oriented-Action-Planning\Assets\Scripts\GOAP\Capabilities\)&#10;1. **StandGuardCapability.asset** - GOAP capability configuration&#10;&#10;## Unity Setup Steps&#10;&#10;### 1. Add Unity Tags&#10;In Unity Editor, add these tags:&#10;- **StandGuardPoint** - For the guard position markers&#10;- **StandGuardAnglePoint** - For the rotation target markers (need at least 2)&#10;&#10;### 2. Create GameObjects in Scene&#10;Create the following GameObjects:&#10;&#10;#### StandGuardPoint Objects&#10;1. Create empty GameObjects where you want guards to stand&#10;2. Tag them with &quot;StandGuardPoint&quot;&#10;3. Position them in strategic locations (hallways, intersections, etc.)&#10;&#10;#### StandGuardAnglePoint Objects&#10;1. Create at least 2 empty GameObjects near each StandGuardPoint&#10;2. Tag them with &quot;StandGuardAnglePoint&quot;&#10;3. Position them to define the guard's rotation arc&#10;   - Example: Place one to the left and one to the right of the guard point&#10;   - The guard will rotate to look between these two points&#10;&#10;### 3. Configure Guard Agent Type&#10;In your GuardAgentTypeFactory (on the GameObject with GoapBehaviour):&#10;1. Add the **StandGuardCapability.asset** to the Capabilities list&#10;2. The action should automatically be higher priority than PatrolAction (baseCost = 0.5 vs 1.0)&#10;&#10;### 4. Verify Sensor Setup&#10;The StandGuardCapability.asset includes all required sensors, but verify in Unity Inspector:&#10;- DifficultySensor → Difficulty WorldKey&#10;- AtStandGuardPointSensor → AtStandGuardPoint WorldKey&#10;- LastStoodGuardSensor → LastStoodGuard WorldKey&#10;- StandGuardTargetSensor → StandGuardTarget TargetKey&#10;- EnergySensor should already exist (from RechargeCapability)&#10;&#10;## Action Behavior Details&#10;&#10;### Conditions (All must be met)&#10;1. **Difficulty ≥ 75** - High difficulty threshold&#10;2. **Within 5 meters** of any StandGuardPoint&#10;3. **Energy &gt; 0** - Guard has some energy&#10;4. **LastStoodGuard &gt; 15 seconds** - Cooldown has expired&#10;5. **Not Alert** - Guard is not in alert/pursuit mode&#10;&#10;### Action Priority&#10;- **baseCost: 0.5** (lower than PatrolAction's 1.0)&#10;- This means StandGuard will **interrupt PatrolAction** when conditions are met&#10;&#10;### Execution Flow&#10;1. **Movement Phase**: Guard walks to nearest StandGuardPoint&#10;2. **Arrival**: Guard stops when within 1.5m of target&#10;3. **Guard Duty (10 seconds)**:&#10;   - Guard stands idle&#10;   - Slowly rotates body between two nearest StandGuardAnglePoints&#10;   - Rotation speed: 2 rad/s&#10;   - Switches direction when within 5° of target angle&#10;4. **Completion**:&#10;   - 15-second cooldown timer starts&#10;   - Guard returns to previous behavior (likely patrol)&#10;&#10;### Animation States Used&#10;- **Walk** - While moving to guard point&#10;- **Idle** - While standing guard (during rotation)&#10;&#10;### Audio&#10;- **PlayWalkLoop()** - While moving to guard point&#10;- **StopWalkLoop()** - On arrival&#10;&#10;## Testing Checklist&#10;&#10;- [ ] Tags created: &quot;StandGuardPoint&quot; and &quot;StandGuardAnglePoint&quot;&#10;- [ ] At least one StandGuardPoint GameObject in scene&#10;- [ ] At least two StandGuardAnglePoint GameObjects near each guard point&#10;- [ ] StandGuardCapability.asset added to GuardAgentTypeFactory&#10;- [ ] Difficulty is set to ≥75% (test with static difficulty mode)&#10;- [ ] Guard has energy &gt; 0&#10;- [ ] Guard is within 5 meters of a StandGuardPoint&#10;- [ ] Guard interrupts patrol when conditions met&#10;- [ ] Guard walks to guard point&#10;- [ ] Guard stands for 10 seconds, rotating between angle points&#10;- [ ] After 10 seconds, guard resumes patrol&#10;- [ ] Guard cannot stand guard again for 15 seconds&#10;&#10;## Debugging Tips&#10;&#10;### Check if Action is Available&#10;Look at the GOAP Graph Viewer in Unity to see if StandGuardGoal/Action is in the plan.&#10;&#10;### Console Logs&#10;The action includes debug logs:&#10;- `[StandGuardAction] {guardName} starting - moving to guard point at {position}`&#10;- `[StandGuardAction] {guardName} arrived at guard point, starting 10s guard duty`&#10;- `[StandGuardAction] {guardName} completed 10s guard duty`&#10;- `[StandGuardAction] {guardName} completed and started cooldown`&#10;- `[StandGuardTimer] {guardName} started cooldown at {time}`&#10;&#10;### Common Issues&#10;1. **Action never triggers**:&#10;   - Check difficulty is ≥75&#10;   - Verify guard is within 5m of StandGuardPoint&#10;   - Check 15-second cooldown hasn't expired&#10;   - Verify tags are correct&#10;&#10;2. **Guard doesn't rotate**:&#10;   - Need at least 2 StandGuardAnglePoint objects&#10;   - Check angle points are tagged correctly&#10;   - Verify angle points are positioned properly (not on top of guard)&#10;&#10;3. **Guard gets stuck**:&#10;   - Ensure StandGuardPoint is on NavMesh&#10;   - Check NavMeshAgent is properly configured&#10;   - Verify arrival threshold (1.5m) is reasonable for your scene&#10;&#10;## Advanced Configuration&#10;&#10;### Adjusting Timing&#10;In `StandGuardAction.cs`:&#10;```csharp&#10;private const float GUARD_DURATION = 10f; // Duration of guard duty&#10;private const float ARRIVAL_THRESHOLD = 1.5f; // Distance to consider &quot;arrived&quot;&#10;private const float ROTATION_SPEED = 2f; // Rotation speed&#10;```&#10;&#10;In `LastStoodGuardSensor.cs`:&#10;```csharp&#10;private const float COOLDOWN_DURATION = 15f; // Cooldown between guards&#10;```&#10;&#10;### Adjusting Priority&#10;In `StandGuardCapability.asset`, change:&#10;```yaml&#10;baseCost: 0.5  # Lower = higher priority&#10;```&#10;&#10;### Adjusting Conditions&#10;In `StandGuardCapability.asset`:&#10;- Change difficulty threshold (currently 75)&#10;- Adjust proximity check (currently within 5m)&#10;- Modify energy requirement (currently &gt; 0)&#10;- Change cooldown duration (currently &gt; 15 seconds)&#10;&#10;## Integration with Existing Systems&#10;&#10;### Difficulty System&#10;- Uses `DifficultyTracker.GetDifficultyF()` to get current difficulty (0-1)&#10;- Converts to percentage (0-100) for GOAP conditions&#10;- Works with both dynamic and static difficulty modes&#10;&#10;### Energy System&#10;- Reuses existing Energy WorldKey and EnergySensor&#10;- Guards won't stand guard if energy is depleted&#10;- Standing guard does NOT consume energy (guards remain idle)&#10;&#10;### Alert System&#10;- Reuses existing IsAlert WorldKey&#10;- Guards won't stand guard while in alert/pursuit mode&#10;- If guard spots player during guard duty, will abort and pursue&#10;&#10;### Patrol System&#10;- StandGuard has higher priority than Patrol (lower baseCost)&#10;- Will interrupt patrol when conditions are met&#10;- Guard resumes patrol after completing guard duty&#10;&#10;## File Summary&#10;&#10;**Created Files (8 total):**&#10;1. WorldKeys/AtStandGuardPoint.cs&#10;2. WorldKeys/LastStoodGuard.cs&#10;3. TargetKeys/StandGuardTarget.cs&#10;4. Sensors/AtStandGuardPointSensor.cs&#10;5. Sensors/LastStoodGuardSensor.cs&#10;6. Sensors/StandGuardTargetSensor.cs&#10;7. Behaviours/StandGuardTimerBehaviour.cs&#10;8. Capabilities/StandGuardCapability.asset&#10;&#10;**Existing Files (reused):**&#10;- WorldKeys/DDA/DifficultyWK.cs&#10;- Sensors/DDA/DifficultySensor.cs&#10;&#10;**Modified Files (1 total):**&#10;1. Actions/StandGuardAction.cs (fully implemented)&#10;&#10;**Existing File (unchanged):**&#10;1. Goals/StandGuardGoal.cs (already exists)&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/GOAP/Sensors/DifficultySensor.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/GOAP/Sensors/DifficultySensor.cs" />
              <option name="updatedContent" value="using CrashKonijn.Agent.Core;&#10;using CrashKonijn.Goap.Runtime;&#10;using CrashKonijn.Goap.Core;&#10;using UnityEngine;&#10;&#10;namespace Assets.Scripts.GOAP.Sensors&#10;{&#10;    [GoapId(&quot;DifficultySensor-e5f6a7b8-c9d0-4e1f-2a3b-4c5d6e7f8a9b&quot;)]&#10;    public class DifficultySensor : LocalWorldSensorBase&#10;    {&#10;        public override void Created() { }&#10;        public override void Update() { }&#10;&#10;        public override SenseValue Sense(IActionReceiver agent, IComponentReference refs)&#10;        {&#10;            // Get difficulty as a percentage (0-100)&#10;            float difficulty = Assets.Scripts.DDA.DifficultyTracker.GetDifficultyF() * 100f;&#10;            return new SenseValue(Mathf.RoundToInt(difficulty));&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/GOAP/WorldKeys/Difficulty.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/GOAP/WorldKeys/Difficulty.cs" />
              <option name="updatedContent" value="using CrashKonijn.Goap.Runtime;&#10;&#10;namespace Assets.Scripts.GOAP.WorldKeys&#10;{&#10;    [GoapId(&quot;Difficulty-c3d4e5f6-a7b8-4c9d-0e1f-2a3b4c5d6e7f&quot;)]&#10;    public class Difficulty : WorldKeyBase {}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Main Menu/MainMenu.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Main Menu/MainMenu.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using UnityEngine.UI;&#10;using TMPro;&#10;using Assets.Scripts.DDA;&#10;using UnityEngine.SceneManagement;&#10;using UnityEngine.EventSystems;&#10;using UnityEngine.InputSystem;&#10;using UnityEngine.InputSystem.UI;&#10;using System;&#10;using System.Collections;&#10;using Assets.Scripts.Systems;&#10;&#10;public class MainMenu : MonoBehaviour&#10;{&#10;    [Header(&quot;UI Panels&quot;)]&#10;    [SerializeField] private GameObject mainPanel;&#10;    [SerializeField] private GameObject creditsPanel;&#10;    [SerializeField] private GameObject difficultyPanel;&#10;    [SerializeField] private GameObject pausePanel;&#10;    [SerializeField] private GameObject gameOverPanel;&#10;    &#10;    [Header(&quot;Main Panel Buttons&quot;)]&#10;    [SerializeField] private Button playButton;&#10;    [SerializeField] private Button creditsButton;&#10;    [SerializeField] private Button exitButton;&#10;    [SerializeField] private Toggle ddaToggle;&#10;    &#10;    [Header(&quot;Difficulty Panel Buttons&quot;)]&#10;    [SerializeField] private Button easyButton;&#10;    [SerializeField] private Button mediumButton;&#10;    [SerializeField] private Button hardButton;&#10;    [SerializeField] private Button difficultyBackButton;&#10;    &#10;    [Header(&quot;Credits Panel Buttons&quot;)]&#10;    [SerializeField] private Button creditsBackButton;&#10;    &#10;    [Header(&quot;Pause Panel Buttons&quot;)]&#10;    [SerializeField] private Button resumeButton;&#10;    [SerializeField] private Button pauseExitButton;&#10;    &#10;    &#10;    [Header(&quot;Game Over Panel Buttons&quot;)]&#10;    [SerializeField] private Button retryButton;&#10;    [SerializeField] private Button gameOverExitButton;&#10;&#10;    [Header(&quot;Gameplay UI&quot;)]&#10;    [SerializeField] private GameObject gameplayCanvas;&#10;&#10;    [Header(&quot;Settings&quot;)]&#10;    [SerializeField] private bool showOnStart = true;&#10;    [SerializeField] private string playerTag = &quot;Player&quot;;&#10;    [SerializeField] private string mainMenuSceneName = &quot;MainMenu&quot;;&#10;    [SerializeField] private string gameplaySceneName = &quot;Jakob&quot;;&#10;    &#10;    [Header(&quot;Input&quot;)]&#10;    [SerializeField] private InputActionAsset uiInputActions;&#10;    &#10;    [Header(&quot;Decor Overlays&quot;)]&#10;    [SerializeField] private Graphic[] nonBlockingGraphics;&#10;    [SerializeField] private CanvasGroup[] nonBlockingCanvasGroups;&#10;    &#10;    [Header(&quot;Audio&quot;)]&#10;    [SerializeField] private AudioSource menuMusicSource;&#10;    [SerializeField] private AudioSource gameplayMusicSource;&#10;    [SerializeField] private AudioSource pauseMusicSource;&#10;    [SerializeField] private AudioSource gameOverMusicSource;&#10;    [SerializeField] private float retryAudioDelay = 1.5f;&#10;    [SerializeField] private float muteAudioDelay = 4f;&#10;    [SerializeField] private float musicFadeInDuration = 4f;&#10;    [SerializeField] private float musicFadeOutDuration = 1f;&#10;    [SerializeField] private float gameOverMusicDelay = 2f;&#10;    [Tooltip(&quot;Tag to find all gameplay audio sources&quot;)]&#10;    [SerializeField] private string gameplayAudioTag = &quot;GameplayAudio&quot;;&#10;    &#10;    private bool gameplayAudioMuted = false;&#10;    private Coroutine pauseMusicFadeCoroutine = null;&#10;    private Coroutine gameOverMusicFadeCoroutine = null;&#10;    private Coroutine gameplayAudioFadeCoroutine = null;&#10;&#10;    // Cached text elements by tag&#10;    private GameObject[] mainPanelTextElements;&#10;    private GameObject[] difficultyPanelTextElements;&#10;    private GameObject[] creditsPanelTextElements;&#10;&#10;    private GameObject player;&#10;    private bool isGamePaused;&#10;    private bool isGameOver;&#10;    private bool isRetrying; // Track if we're currently in a retry flow&#10;    private bool isTransitioningToGameplay;&#10;    private EventSystem menuEventSystem;&#10;    private PlayerInput playerInput;&#10;    private InputSystemUIInputModule menuInputModule;&#10;&#10;    public static MainMenu Instance { get; private set; }&#10;&#10;    private bool IsGameplaySceneLoaded =&gt; SceneManager.GetSceneByName(gameplaySceneName).isLoaded;&#10;&#10;    bool gameStarted = false;&#10;&#10;    public static Action fadeToGameplayScene;&#10;    public static void OnFadeToGameplayScene() =&gt; fadeToGameplayScene?.Invoke();&#10;&#10;&#10;    private void Awake()&#10;    {&#10;        if (Instance == null)&#10;        {&#10;            Instance = this;&#10;            &#10;            // Make the entire canvas hierarchy persistent (not just this script object)&#10;            // Find the root canvas object&#10;            Transform canvasRoot = transform;&#10;            while (canvasRoot.parent != null)&#10;            {&#10;                canvasRoot = canvasRoot.parent;&#10;            }&#10;            &#10;            // Ensure it's at root and make it persistent&#10;            canvasRoot.SetParent(null);&#10;            DontDestroyOnLoad(canvasRoot.gameObject);&#10;            &#10;            Debug.Log($&quot;[MainMenu] Made {canvasRoot.name} persistent across scenes&quot;);&#10;            &#10;            EnsureEventSystem();&#10;        }&#10;        else&#10;        {&#10;            Destroy(gameObject);&#10;        }&#10;    }&#10;&#10;    private void OnEnable()&#10;    {&#10;        SceneManager.sceneLoaded += OnSceneLoaded;&#10;        // Subscribe to checkpoint load completion&#10;        CheckpointManager.loadCheckpoint += OnCheckpointLoaded;&#10;        ObjectivesManager.objectiveStarted += BeginGameMusic;&#10;        PlayerActions.playerEscaped += OnPlayerEscapedDisableGameplayMusic;&#10;    }&#10;&#10;    private void OnDisable()&#10;    {&#10;        SceneManager.sceneLoaded -= OnSceneLoaded;&#10;        ObjectivesManager.objectiveStarted -= BeginGameMusic;&#10;        PlayerActions.playerEscaped -= OnPlayerEscapedDisableGameplayMusic;&#10;    }&#10;&#10;    private void OnPlayerEscapedDisableGameplayMusic()&#10;    {&#10;        if (gameplayMusicSource)&#10;        {&#10;            gameplayMusicSource.enabled = false;&#10;        }&#10;    }&#10;&#10;    private void Start()&#10;    {&#10;        Debug.Log($&quot;[MainMenu] ========== START CALLED on {gameObject.name} ==========&quot;);&#10;        Debug.Log($&quot;[MainMenu] Instance check - This: {this.GetInstanceID()}, Singleton: {Instance?.GetInstanceID()}&quot;);&#10;&#10;        // FIRST: Immediately hide all secondary panels to ensure clean state&#10;        // This must happen before any other logic to prevent overlapping UI&#10;        Debug.Log($&quot;[MainMenu] Panel references - Main: {mainPanel != null}, Credits: {creditsPanel != null}, Difficulty: {difficultyPanel != null}, Pause: {pausePanel != null}, GameOver: {gameOverPanel != null}&quot;);&#10;&#10;        if (creditsPanel)&#10;        {&#10;            creditsPanel.SetActive(false);&#10;            Debug.Log($&quot;[MainMenu] CreditsPanel deactivated - Active: {creditsPanel.activeSelf}&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] CreditsPanel reference is NULL!&quot;);&#10;        }&#10;&#10;        if (difficultyPanel)&#10;        {&#10;            difficultyPanel.SetActive(false);&#10;            Debug.Log($&quot;[MainMenu] DifficultyPanel deactivated - Active: {difficultyPanel.activeSelf}&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] DifficultyPanel reference is NULL!&quot;);&#10;        }&#10;&#10;        if (pausePanel)&#10;        {&#10;            pausePanel.SetActive(false);&#10;            Debug.Log($&quot;[MainMenu] PausePanel deactivated - Active: {pausePanel.activeSelf}&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] PausePanel reference is NULL!&quot;);&#10;        }&#10;&#10;        if (gameOverPanel)&#10;        {&#10;            gameOverPanel.SetActive(false);&#10;            Debug.Log($&quot;[MainMenu] GameOverPanel deactivated - Active: {gameOverPanel.activeSelf}&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] GameOverPanel reference is NULL!&quot;);&#10;        }&#10;&#10;        // Ensure main panel is visible for normal startup&#10;        if (mainPanel)&#10;        {&#10;            mainPanel.SetActive(true);&#10;            Debug.Log($&quot;[MainMenu] MainPanel activated - Active: {mainPanel.activeSelf}&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] MainPanel reference is NULL!&quot;);&#10;        }&#10;&#10;        Debug.Log(&quot;[MainMenu] Initial panel state set - only MainPanel should be visible&quot;);&#10;&#10;        // CRITICAL: Ensure EventSystem exists for button clicks&#10;        var eventSystem = UnityEngine.EventSystems.EventSystem.current;&#10;        if (eventSystem == null)&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] No EventSystem found! Creating one...&quot;);&#10;            var eventSystemObj = new GameObject(&quot;EventSystem&quot;);&#10;            eventSystemObj.AddComponent&lt;UnityEngine.EventSystems.EventSystem&gt;();&#10;            eventSystemObj.AddComponent&lt;UnityEngine.EventSystems.StandaloneInputModule&gt;();&#10;            Debug.Log(&quot;[MainMenu] EventSystem created&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.Log($&quot;[MainMenu] EventSystem found: {eventSystem.gameObject.name}&quot;);&#10;        }&#10;&#10;        // CRITICAL: Ensure FadeScreen isn't blocking input AND is transparent for main menu&#10;        var fadeScreen = GameObject.Find(&quot;FadeScreen&quot;)?.GetComponent&lt;UnityEngine.UI.Image&gt;();&#10;        if (fadeScreen != null)&#10;        {&#10;            if (fadeScreen.raycastTarget)&#10;            {&#10;                fadeScreen.raycastTarget = false;&#10;                Debug.Log(&quot;[MainMenu] FadeScreen raycasts disabled to unblock main menu input&quot;);&#10;            }&#10;&#10;            if (fadeScreen.color.a &gt; 0f)&#10;            {&#10;                fadeScreen.color = new Color(0, 0, 0, 0);&#10;                Debug.Log(&quot;[MainMenu] FadeScreen color reset to transparent for main menu&quot;);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] FadeScreen not found!&quot;);&#10;        }&#10;&#10;        // Find player reference&#10;        player = GameObject.FindGameObjectWithTag(playerTag);&#10;&#10;        // Auto-find gameplay canvas if not assigned&#10;        if (!gameplayCanvas)&#10;        {&#10;            // Try to find a canvas named &quot;Canvas&quot; or &quot;GameplayCanvas&quot; or &quot;HUD&quot;&#10;            gameplayCanvas = GameObject.Find(&quot;Canvas&quot;) ?? GameObject.Find(&quot;GameplayCanvas&quot;) ?? GameObject.Find(&quot;HUD&quot;);&#10;        }&#10;&#10;        // Cache text elements by tags&#10;        CacheTextElements();&#10;&#10;        // Setup button listeners&#10;        SetupButtonListeners();&#10;&#10;        // Ensure canvas is properly configured for input&#10;        EnsureCanvasConfiguration();&#10;        ConfigureDecorativeOverlays();&#10;&#10;        // Check if we're auto-starting from a retry&#10;        bool autoStart = PlayerPrefs.GetInt(&quot;RetryAutoStart&quot;, 0) == 1;&#10;        &#10;        if (autoStart)&#10;        {&#10;            Debug.Log(&quot;[MainMenu] Auto-starting from retry&quot;);&#10;            &#10;            // Restore DDA settings&#10;            bool wasDDAEnabled = PlayerPrefs.GetInt(&quot;RetryDDAEnabled&quot;, 1) == 1;&#10;            int previousDifficulty = PlayerPrefs.GetInt(&quot;RetryDifficulty&quot;, 0);&#10;            &#10;            if (wasDDAEnabled)&#10;            {&#10;                // Restore DDA mode&#10;                DifficultyTracker.EnableTestingMode(false);&#10;                Debug.Log(&quot;[MainMenu] Restored DDA mode from retry&quot;);&#10;            }&#10;            else&#10;            {&#10;                // Restore static difficulty mode&#10;                DifficultyTracker.EnableTestingMode(true);&#10;                DifficultyTracker.SetTestingDifficultyPercent(previousDifficulty);&#10;                Debug.Log($&quot;[MainMenu] Restored static difficulty {previousDifficulty}% from retry&quot;);&#10;            }&#10;            &#10;            // Clear the retry flag&#10;            PlayerPrefs.DeleteKey(&quot;RetryAutoStart&quot;);&#10;            PlayerPrefs.DeleteKey(&quot;RetryDDAEnabled&quot;);&#10;            PlayerPrefs.DeleteKey(&quot;RetryDifficulty&quot;);&#10;            PlayerPrefs.Save();&#10;&#10;            // Start game immediately without showing menu&#10;            // StartGameplayScene();&#10;            // Fade to gameplay scene + audio fade&#10;            OnFadeToGameplayScene();&#10;            StartCoroutine(FadeOutMusic(menuMusicSource, 1f, false)); // 1f matches default fade out duration&#10;        }&#10;        else&#10;        {&#10;            // Normal start - setup initial state&#10;            if (showOnStart)&#10;            {&#10;                ShowMenu();&#10;            }&#10;            else&#10;            {&#10;                HideMenu();&#10;            }&#10;        }&#10;&#10;        // Initialize DDA toggle state (only if not auto-starting)&#10;        if (!autoStart &amp;&amp; ddaToggle)&#10;        {&#10;            ddaToggle.isOn = true; // Default to DDA enabled&#10;            OnDDAToggleChanged(ddaToggle.isOn);&#10;        }&#10;    }&#10;&#10;    private void Update()&#10;    {&#10;        // Don't allow ESC key to trigger pause menu if any main menu panels are showing&#10;        if ((mainPanel != null &amp;&amp; mainPanel.activeSelf) ||&#10;            (creditsPanel != null &amp;&amp; creditsPanel.activeSelf) ||&#10;            (difficultyPanel != null &amp;&amp; difficultyPanel.activeSelf))&#10;        {&#10;            return; // Ignore ESC key when on main menu screens&#10;        }&#10;&#10;        // Allow ESC key to show pause menu during gameplay (not game over, not already paused)&#10;        if (Input.GetKeyDown(KeyCode.Escape) &amp;&amp; !isGamePaused &amp;&amp; !isGameOver)&#10;        {&#10;            Debug.Log(&quot;[MainMenu] ESC pressed - showing pause menu&quot;);&#10;            ShowPauseMenu();&#10;        }&#10;        else if (Input.GetKeyDown(KeyCode.Escape) &amp;&amp; isGameOver)&#10;        {&#10;            Debug.Log(&quot;[MainMenu] ESC pressed but game is over - ignoring&quot;);&#10;        }&#10;        else if (Input.GetKeyDown(KeyCode.Escape) &amp;&amp; isGamePaused)&#10;        {&#10;            Debug.Log(&quot;[MainMenu] ESC pressed while paused - resuming game&quot;);&#10;            OnResumeClicked();&#10;        }&#10;    }&#10;&#10;    public void ShowMenu()&#10;    {&#10;        ShowMenu(shouldUnloadGameplay: false);&#10;    }&#10;&#10;    public void ShowMenu(bool shouldUnloadGameplay)&#10;    {&#10;        GameResetService.ResetGoapSystems();&#10;        isGamePaused = true;&#10;&#10;        SetGameplayInputActive(false);&#10;        // Show the main menu&#10;        if (mainPanel) mainPanel.SetActive(true);&#10;        if (creditsPanel) creditsPanel.SetActive(false);&#10;        if (difficultyPanel) difficultyPanel.SetActive(false);&#10;        if (pausePanel) pausePanel.SetActive(false);&#10;        if (gameOverPanel) gameOverPanel.SetActive(false);&#10;&#10;        // Show MainPanel text elements&#10;        ShowMainPanelText();&#10;&#10;        // Hide gameplay UI elements&#10;        HideGameplayUI();&#10;&#10;        // Pause the game&#10;        // Time.timeScale = 0f;&#10;&#10;        // Mute gameplay audio and play menu music&#10;        MuteGameplayAudio();&#10;        PlayMenuMusic();&#10;&#10;        // Disable player controls&#10;        if (player)&#10;        {&#10;            DisablePlayerControls();&#10;        }&#10;&#10;        // Unlock and show cursor&#10;        Cursor.lockState = CursorLockMode.None;&#10;        Cursor.visible = true;&#10;&#10;        // Only unload gameplay scene if explicitly requested (e.g., after winning the game)&#10;        if (shouldUnloadGameplay &amp;&amp; IsGameplaySceneLoaded)&#10;        {&#10;            Debug.Log(&quot;[MainMenu] Unloading gameplay scene to ensure clean state for next game&quot;);&#10;            UnloadGameplayScene();&#10;        }&#10;    }&#10;&#10;    public void ShowPauseMenu()&#10;    {&#10;        isGamePaused = true;&#10;        &#10;        SetGameplayInputActive(false);&#10;        &#10;        // Ensure EventSystem is active and ready&#10;        EnsureEventSystemActive();&#10;        &#10;        // Show the pause menu&#10;        if (mainPanel) mainPanel.SetActive(false);&#10;        if (creditsPanel) creditsPanel.SetActive(false);&#10;        if (difficultyPanel) difficultyPanel.SetActive(false);&#10;        if (pausePanel) &#10;        {&#10;            pausePanel.SetActive(true);&#10;            Debug.Log($&quot;[MainMenu] PausePanel.SetActive(true) called - ActiveSelf={pausePanel.activeSelf}, ActiveInHierarchy={pausePanel.activeInHierarchy}&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.LogError(&quot;[MainMenu] PausePanel reference is NULL!&quot;);&#10;        }&#10;        if (gameOverPanel) gameOverPanel.SetActive(false);&#10;&#10;        // Hide gameplay UI elements&#10;        HideGameplayUI();&#10;&#10;        // Pause the game&#10;        Time.timeScale = 0f;&#10;&#10;        // Disable player controls&#10;        if (player)&#10;        {&#10;            DisablePlayerControls();&#10;        }&#10;&#10;        // Unlock and show cursor&#10;        Cursor.lockState = CursorLockMode.None;&#10;        Cursor.visible = true;&#10;        &#10;        // Mute gameplay audio and play pause music with fade-in&#10;        MuteGameplayAudio();&#10;        ToggleGameMusicWithFade(false);&#10;        PlayPauseMusicWithFadeIn();&#10;        &#10;        // Force enable button GameObjects if they're disabled&#10;        ForceEnableButtons();&#10;        &#10;        // Debug button states AFTER showing panels&#10;        DebugButtonStates();&#10;        &#10;        // Check for Graphic Raycaster&#10;        CheckGraphicRaycaster();&#10;        &#10;        Debug.Log(&quot;[MainMenu] Game Paused - Pause Panel Active&quot;);&#10;    }&#10;&#10;    public void ShowGameOverMenu()&#10;    {&#10;        Debug.Log(&quot;[MainMenu] ========== SHOWING GAME OVER MENU ==========&quot;);&#10;        isGamePaused = true;&#10;        isGameOver = true;&#10;        &#10;        SetGameplayInputActive(false);&#10;        &#10;        // Ensure EventSystem is active and ready&#10;        EnsureEventSystemActive();&#10;        &#10;        // Show the game over menu&#10;        if (mainPanel) mainPanel.SetActive(false);&#10;        if (creditsPanel) creditsPanel.SetActive(false);&#10;        if (difficultyPanel) difficultyPanel.SetActive(false);&#10;        if (pausePanel) pausePanel.SetActive(false);&#10;        if (gameOverPanel) gameOverPanel.SetActive(true);&#10;&#10;        // Hide gameplay UI elements&#10;        HideGameplayUI();&#10;&#10;        // Pause the game&#10;        Time.timeScale = 0f;&#10;&#10;        // Disable player controls&#10;        if (player)&#10;        {&#10;            DisablePlayerControls();&#10;        }&#10;&#10;        // Unlock and show cursor&#10;        Cursor.lockState = CursorLockMode.None;&#10;        Cursor.visible = true;&#10;        &#10;        // Mute gameplay audio with fade and play game over music with fade-in&#10;        StartCoroutine(MuteGameplayAudioDelayed(muteAudioDelay));&#10;        PlayGameOverMusicWithFadeIn();&#10;        &#10;        // Force enable button GameObjects if they're disabled&#10;        ForceEnableButtons();&#10;        &#10;        // Debug button states&#10;        DebugButtonStates();&#10;        &#10;        // Check for Graphic Raycaster&#10;        CheckGraphicRaycaster();&#10;        &#10;        Debug.Log(&quot;[MainMenu] Game Over - Game Over Panel Active&quot;);&#10;    }&#10;&#10;    public void HideMenu()&#10;    {&#10;        Debug.Log(&quot;[MainMenu] ========== HIDING ALL MENUS ==========&quot;);&#10;        Debug.Log($&quot;[MainMenu] Previous state - isGamePaused: {isGamePaused}, isGameOver: {isGameOver}&quot;);&#10;        &#10;        isGamePaused = false;&#10;        isGameOver = false;&#10;&#10;        // Hide ALL panels&#10;        if (mainPanel) mainPanel.SetActive(false);&#10;        if (creditsPanel) creditsPanel.SetActive(false);&#10;        if (difficultyPanel) difficultyPanel.SetActive(false);&#10;        if (pausePanel) &#10;        {&#10;            pausePanel.SetActive(false);&#10;            Debug.Log(&quot;[MainMenu] Deactivated Pause panel&quot;);&#10;        }&#10;        if (gameOverPanel) &#10;        {&#10;            gameOverPanel.SetActive(false);&#10;            Debug.Log(&quot;[MainMenu] Deactivated GameOver panel&quot;);&#10;        }&#10;&#10;        // Hide all text elements&#10;        HideAllPanelText();&#10;&#10;        // Re-enable gameplay EventSystems&#10;        RestoreGameplayEventSystems();&#10;&#10;        // Show gameplay UI elements&#10;        ShowGameplayUI();&#10;&#10;        // Unpause the game&#10;        Time.timeScale = 1f;&#10;&#10;        // Enable player controls&#10;        if (player)&#10;        {&#10;            EnablePlayerControls();&#10;        }&#10;&#10;        // Lock and hide cursor for gameplay&#10;        Cursor.lockState = CursorLockMode.Locked;&#10;        Cursor.visible = false;&#10;        &#10;        // Stop all menu music with fade out and unmute gameplay audio (unless retrying, which has its own delay)&#10;        StopMenuMusic();&#10;        StopPauseMusicWithFadeOut();&#10;        StopGameOverMusicWithFadeOut();&#10;        if (!isRetrying &amp;&amp; gameStarted)&#10;        {&#10;            UnmuteGameplayAudio();&#10;        }&#10;        &#10;        SetGameplayInputActive(true);&#10;    }&#10;&#10;    private void HideGameplayUI()&#10;    {&#10;        if (gameplayCanvas) gameplayCanvas.SetActive(false);&#10;    }&#10;&#10;    private void ShowGameplayUI()&#10;    {&#10;        if (gameplayCanvas) gameplayCanvas.SetActive(true);&#10;    }&#10;&#10;    private void OnPlayClicked()&#10;    {&#10;        // Check if DDA is enabled&#10;        bool isDDAEnabled = ddaToggle &amp;&amp; ddaToggle.isOn;&#10;&#10;        if (isDDAEnabled)&#10;        {&#10;            // DDA is enabled - start game immediately with dynamic difficulty&#10;            DifficultyTracker.EnableTestingMode(false);&#10;            Debug.Log(&quot;Dynamic Difficulty Adjustment: ENABLED - Starting game&quot;);&#10;            //StartGameplayScene();&#10;            // Fade to gameplay scene + audio fade&#10;            OnFadeToGameplayScene();&#10;            StartCoroutine(FadeOutMusic(menuMusicSource, 1f, false)); // 1f matches default fade out duration&#10;        }&#10;        else&#10;        {&#10;            // DDA is disabled - show difficulty selection panel&#10;            Debug.Log(&quot;Static Difficulty Mode - Select difficulty&quot;);&#10;            if (mainPanel) mainPanel.SetActive(false);&#10;            if (difficultyPanel) difficultyPanel.SetActive(true);&#10;            &#10;            // Show difficulty panel text elements&#10;            ShowDifficultyPanelText();&#10;        }&#10;    }&#10;&#10;    private void OnDifficultySelected(int difficultyPercent)&#10;    {&#10;        // Set static difficulty&#10;        DifficultyTracker.EnableTestingMode(true);&#10;        DifficultyTracker.SetTestingDifficultyPercent(difficultyPercent);&#10;        &#10;        string difficultyName = difficultyPercent switch&#10;        {&#10;            0 =&gt; &quot;Easy&quot;,&#10;            50 =&gt; &quot;Medium&quot;,&#10;            100 =&gt; &quot;Hard&quot;,&#10;            _ =&gt; &quot;Unknown&quot;&#10;        };&#10;        &#10;        Debug.Log($&quot;Static Difficulty Set: {difficultyName} ({difficultyPercent}%) - Starting game&quot;);&#10;&#10;        // Start the game&#10;        //StartGameplayScene();&#10;        // Fade to gameplay scene + audio fade&#10;        OnFadeToGameplayScene();&#10;        StartCoroutine(FadeOutMusic(menuMusicSource, 1f, false)); // 1f matches default fade out duration&#10;    }&#10;&#10;    private void OnCreditsClicked()&#10;    {&#10;        if (mainPanel) mainPanel.SetActive(false);&#10;        if (creditsPanel) creditsPanel.SetActive(true);&#10;        ShowCreditsPanelText();&#10;    }&#10;&#10;    public void OnBackFromCredits()&#10;    {&#10;        if (mainPanel) mainPanel.SetActive(true);&#10;        if (creditsPanel) creditsPanel.SetActive(false);&#10;        ShowMainPanelText();&#10;    }&#10;&#10;    public void OnBackFromDifficulty()&#10;    {&#10;        if (difficultyPanel) difficultyPanel.SetActive(false);&#10;        if (mainPanel) mainPanel.SetActive(true);&#10;        ShowMainPanelText();&#10;    }&#10;&#10;    private void OnExitClicked()&#10;    {&#10;        #if UNITY_EDITOR&#10;            UnityEditor.EditorApplication.isPlaying = false;&#10;        #else&#10;            Application.Quit();&#10;        #endif&#10;    }&#10;&#10;    private void OnDDAToggleChanged(bool isEnabled)&#10;    {&#10;        // Just log the change - actual behavior happens on Play button&#10;        if (isEnabled)&#10;        {&#10;            Debug.Log(&quot;Dynamic Difficulty Mode Selected&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.Log(&quot;Static Difficulty Mode Selected&quot;);&#10;        }&#10;    }&#10;&#10;    private void DisablePlayerControls()&#10;    {&#10;        if (!player) return;&#10;&#10;        // Disable player input components&#10;        var playerActions = player.GetComponent&lt;PlayerActions&gt;();&#10;        if (playerActions) playerActions.enabled = false;&#10;&#10;        var playerMovement = player.GetComponent&lt;MonoBehaviour&gt;();&#10;        if (playerMovement &amp;&amp; playerMovement.GetType().Name.Contains(&quot;Movement&quot;))&#10;        {&#10;            playerMovement.enabled = false;&#10;        }&#10;&#10;        // Disable any other player control scripts as needed&#10;        var allPlayerScripts = player.GetComponents&lt;MonoBehaviour&gt;();&#10;        foreach (var script in allPlayerScripts)&#10;        {&#10;            string scriptName = script.GetType().Name;&#10;            if (scriptName.Contains(&quot;Player&quot;) &amp;&amp; &#10;                (scriptName.Contains(&quot;Movement&quot;) || scriptName.Contains(&quot;Interact&quot;) || scriptName.Contains(&quot;Action&quot;)))&#10;            {&#10;                script.enabled = false;&#10;            }&#10;        }&#10;    }&#10;&#10;    private void EnablePlayerControls()&#10;    {&#10;        if (!player) return;&#10;&#10;        // Re-enable player input components&#10;        var playerActions = player.GetComponent&lt;PlayerActions&gt;();&#10;        if (playerActions) playerActions.enabled = true;&#10;&#10;        // Re-enable movement and interaction&#10;        var allPlayerScripts = player.GetComponents&lt;MonoBehaviour&gt;();&#10;        foreach (var script in allPlayerScripts)&#10;        {&#10;            string scriptName = script.GetType().Name;&#10;            if (scriptName.Contains(&quot;Player&quot;) &amp;&amp; &#10;                (scriptName.Contains(&quot;Movement&quot;) || scriptName.Contains(&quot;Interact&quot;) || scriptName.Contains(&quot;Action&quot;)))&#10;            {&#10;                script.enabled = true;&#10;            }&#10;        }&#10;        &#10;        // Restore PlayerInteract state - trigger the canInteract event to ensure proper state&#10;        var playerInteract = player.GetComponent&lt;PlayerInteract&gt;();&#10;        if (playerInteract)&#10;        {&#10;            // Re-trigger the interact permission based on current objective state&#10;            // This ensures the component gets the correct canInteract state after being re-enabled&#10;            if(ObjectivesManager.Instance != null &amp;&amp; ObjectivesManager.Instance.completedTutorial)&#10;            {&#10;                PlayerActions.OnCanInteract(true);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void RefreshObjectiveDisplay()&#10;    {&#10;        // Trigger the objectives manager to re-display the current objective&#10;        if (ObjectivesManager.Instance != null &amp;&amp; ObjectivesManager.Instance.CurrentObjective != null)&#10;        {&#10;            ObjectivesManager.OnDisplayObjective(ObjectivesManager.Instance.CurrentObjective, 0, 0f);&#10;        }&#10;    }&#10;&#10;    public void StartGameplayScene()&#10;    {&#10;        if (IsGameplaySceneLoaded)&#10;        {&#10;            Debug.Log(&quot;[MainMenu] Gameplay scene already loaded - unloading it first to start fresh&quot;);&#10;            UnloadGameplayScene();&#10;            // After unloading completes, we'll load it fresh&#10;            StartCoroutine(WaitForUnloadThenLoadGameplay());&#10;            return;&#10;        }&#10;&#10;        isTransitioningToGameplay = true;&#10;        HideMenu();&#10;        Debug.Log($&quot;[MainMenu] Loading gameplay scene '{gameplaySceneName}' (additive)&quot;);&#10;        SceneManager.LoadSceneAsync(gameplaySceneName, LoadSceneMode.Additive);&#10;    }&#10;&#10;    private System.Collections.IEnumerator WaitForUnloadThenLoadGameplay()&#10;    {&#10;        // Wait for unload to complete&#10;        while (IsGameplaySceneLoaded)&#10;        {&#10;            yield return null;&#10;        }&#10;&#10;        Debug.Log(&quot;[MainMenu] Old gameplay scene unloaded, loading fresh gameplay scene&quot;);&#10;        isTransitioningToGameplay = true;&#10;        HideMenu();&#10;        SceneManager.LoadSceneAsync(gameplaySceneName, LoadSceneMode.Additive);&#10;    }&#10;&#10;    private void LoadMainMenuScene()&#10;    {&#10;        isTransitioningToGameplay = false;&#10;        Debug.Log($&quot;[MainMenu] Returning to main menu scene '{mainMenuSceneName}'&quot;);&#10;        var menuScene = SceneManager.GetSceneByName(mainMenuSceneName);&#10;        if (menuScene.isLoaded)&#10;        {&#10;            SceneManager.SetActiveScene(menuScene);&#10;            ShowMenu();&#10;            UnloadGameplayScene();&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning($&quot;[MainMenu] Main menu scene '{mainMenuSceneName}' is not loaded yet.&quot;);&#10;        }&#10;    }&#10;&#10;    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)&#10;    {&#10;        if (scene.name == gameplaySceneName)&#10;        {&#10;            CacheGameplayReferences(scene);&#10;            SceneManager.SetActiveScene(scene);&#10;            if (isTransitioningToGameplay)&#10;            {&#10;                HideMenu();&#10;                isTransitioningToGameplay = false;&#10;                &#10;                // Unload the MainMenu scene after gameplay scene is loaded&#10;                // DontDestroyOnLoad objects (like the menu canvas) will persist&#10;                UnloadMainMenuScene();&#10;            }&#10;        }&#10;        else if (scene.name == mainMenuSceneName)&#10;        {&#10;            SceneManager.SetActiveScene(scene);&#10;            ShowMenu();&#10;        }&#10;    }&#10;&#10;    private void CacheGameplayReferences(Scene scene)&#10;    {&#10;        player = GameObject.FindGameObjectWithTag(playerTag);&#10;        playerInput = player?.GetComponent&lt;PlayerInput&gt;();&#10;        if (gameplayCanvas == null || gameplayCanvas.scene != scene)&#10;        {&#10;            gameplayCanvas = FindGameplayCanvas(scene);&#10;        }&#10;    }&#10;&#10;    private GameObject FindGameplayCanvas(Scene scene)&#10;    {&#10;        string[] candidateNames = { &quot;GameplayCanvas&quot;, &quot;HUD&quot;, &quot;Canvas&quot; };&#10;        foreach (var candidateName in candidateNames)&#10;        {&#10;            var candidate = GameObject.Find(candidateName);&#10;            if (candidate &amp;&amp; candidate.scene == scene)&#10;            {&#10;                return candidate;&#10;            }&#10;        }&#10;&#10;        foreach (var root in scene.GetRootGameObjects())&#10;        {&#10;            var canvas = root.GetComponentInChildren&lt;Canvas&gt;(true);&#10;            if (canvas)&#10;            {&#10;                return canvas.gameObject;&#10;            }&#10;        }&#10;&#10;        return null;&#10;    }&#10;&#10;    private void OnDestroy()&#10;    {&#10;        SceneManager.sceneLoaded -= OnSceneLoaded;&#10;        &#10;        // Unsubscribe from checkpoint events&#10;        CheckpointManager.loadCheckpoint -= OnCheckpointLoaded;&#10;        &#10;        // Clean up listeners&#10;        if (playButton) playButton.onClick.RemoveListener(OnPlayClicked);&#10;        if (creditsButton) creditsButton.onClick.RemoveListener(OnCreditsClicked);&#10;        if (exitButton) exitButton.onClick.RemoveListener(OnExitClicked);&#10;        if (creditsBackButton) creditsBackButton.onClick.RemoveListener(OnBackFromCredits);&#10;        if (difficultyBackButton) difficultyBackButton.onClick.RemoveListener(OnBackFromDifficulty);&#10;        if (ddaToggle) ddaToggle.onValueChanged.RemoveListener(OnDDAToggleChanged);&#10;        if (easyButton) easyButton.onClick.RemoveListener(() =&gt; OnDifficultySelected(0));&#10;        if (mediumButton) mediumButton.onClick.RemoveListener(() =&gt; OnDifficultySelected(50));&#10;        if (hardButton) hardButton.onClick.RemoveListener(() =&gt; OnDifficultySelected(100));&#10;        &#10;        // Pause panel&#10;        if (resumeButton) resumeButton.onClick.RemoveListener(OnResumeClicked);&#10;        if (pauseExitButton) pauseExitButton.onClick.RemoveListener(OnExitClicked);&#10;        &#10;        // Game over panel&#10;        if (retryButton) retryButton.onClick.RemoveListener(OnRetryClicked);&#10;        if (gameOverExitButton) gameOverExitButton.onClick.RemoveListener(OnExitClicked);&#10;        &#10;        // Clear singleton instance&#10;        if (Instance == this)&#10;        {&#10;            Instance = null;&#10;        }&#10;    }&#10;&#10;    private void OnResumeClicked()&#10;    {&#10;        Debug.Log(&quot;[MainMenu] Resuming game&quot;);&#10;        HideMenu();&#10;    }&#10;&#10;    private void OnRetryClicked()&#10;    {&#10;        Debug.Log(&quot;[MainMenu] Retrying level - Using checkpoint system&quot;);&#10;        isRetrying = true;&#10;        isGameOver = false;&#10;        HideMenu();&#10;        &#10;        // Start delayed audio unmute (gameplay audio stays muted for 2 seconds)&#10;        StartCoroutine(UnmuteGameplayAudioDelayed(retryAudioDelay));&#10;        &#10;        CheckpointManager.Instance?.BeginLoading();&#10;    }&#10;&#10;    private void OnCheckpointLoaded()&#10;    {&#10;        if (!isRetrying) return;&#10;&#10;        isRetrying = false;&#10;        Debug.Log(&quot;[MainMenu] Checkpoint loaded, retry complete&quot;);&#10;        GameOverManager.Instance?.ResetGameOver();&#10;    }&#10;&#10;    private void UnloadGameplayScene()&#10;    {&#10;        var gameplayScene = SceneManager.GetSceneByName(gameplaySceneName);&#10;        if (gameplayScene.isLoaded)&#10;        {&#10;            SceneManager.UnloadSceneAsync(gameplayScene);&#10;        }&#10;    }&#10;&#10;    private void UnloadMainMenuScene()&#10;    {&#10;        var mainMenuScene = SceneManager.GetSceneByName(mainMenuSceneName);&#10;        if (mainMenuScene.isLoaded)&#10;        {&#10;            Debug.Log($&quot;[MainMenu] Unloading MainMenu scene - DontDestroyOnLoad objects will persist&quot;);&#10;            SceneManager.UnloadSceneAsync(mainMenuScene);&#10;        }&#10;    }&#10;&#10;    private void EnsureEventSystem()&#10;    {&#10;        if (menuEventSystem &amp;&amp; menuEventSystem.gameObject)&#10;        {&#10;            SetupInputModule();&#10;            return;&#10;        }&#10;&#10;        // Search for existing EventSystem in the entire hierarchy&#10;        menuEventSystem = FindFirstObjectByType&lt;EventSystem&gt;();&#10;        &#10;        if (menuEventSystem == null)&#10;        {&#10;            // Create EventSystem as child of the canvas root, not this script object&#10;            Transform canvasRoot = transform;&#10;            while (canvasRoot.parent != null)&#10;            {&#10;                canvasRoot = canvasRoot.parent;&#10;            }&#10;            &#10;            var eventSystemContainer = new GameObject(&quot;MainMenu EventSystem&quot;);&#10;            eventSystemContainer.transform.SetParent(canvasRoot);&#10;            menuEventSystem = eventSystemContainer.AddComponent&lt;EventSystem&gt;();&#10;            Debug.Log(&quot;[MainMenu] Created persistent EventSystem for menu interaction&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.Log($&quot;[MainMenu] Found existing EventSystem: {menuEventSystem.name}&quot;);&#10;        }&#10;&#10;        SetupInputModule();&#10;    }&#10;&#10;    private void EnsureEventSystemActive()&#10;    {&#10;        // CRITICAL: Get canvas root and ensure it's on top&#10;        Transform canvasRoot = transform;&#10;        while (canvasRoot.parent != null)&#10;        {&#10;            canvasRoot = canvasRoot.parent;&#10;        }&#10;        &#10;        var canvas = canvasRoot.GetComponent&lt;Canvas&gt;();&#10;        if (canvas)&#10;        {&#10;            // FORCE canvas to render on top of everything else&#10;            canvas.sortingOrder = 9999;&#10;            canvas.overrideSorting = true;&#10;            Debug.Log($&quot;[MainMenu] Set Canvas sortingOrder to 9999 to render on top&quot;);&#10;            &#10;            // Ensure canvas render mode allows interaction&#10;            if (canvas.renderMode == RenderMode.ScreenSpaceCamera &amp;&amp; canvas.worldCamera == null)&#10;            {&#10;                Debug.LogWarning(&quot;[MainMenu] Canvas is in Camera mode but has no camera assigned!&quot;);&#10;            }&#10;            &#10;            // Ensure Graphic Raycaster is enabled&#10;            var raycaster = canvas.GetComponent&lt;GraphicRaycaster&gt;();&#10;            if (raycaster)&#10;            {&#10;                if (!raycaster.enabled)&#10;                {&#10;                    raycaster.enabled = true;&#10;                    Debug.Log(&quot;[MainMenu] Enabled Graphic Raycaster on Canvas&quot;);&#10;                }&#10;            }&#10;            else&#10;            {&#10;                Debug.LogError(&quot;[MainMenu] GraphicRaycaster MISSING! Adding it...&quot;);&#10;                raycaster = canvas.gameObject.AddComponent&lt;GraphicRaycaster&gt;();&#10;                Debug.Log(&quot;[MainMenu] GraphicRaycaster added to Canvas!&quot;);&#10;            }&#10;        }&#10;        &#10;        // Find all EventSystems in the scene&#10;        EventSystem[] allEventSystems = FindObjectsByType&lt;EventSystem&gt;(FindObjectsSortMode.None);&#10;        &#10;        Debug.Log($&quot;[MainMenu] Found {allEventSystems.Length} EventSystem(s) in scene&quot;);&#10;        &#10;        // Disable all EventSystems except our menu one&#10;        foreach (var es in allEventSystems)&#10;        {&#10;            if (es == menuEventSystem)&#10;            {&#10;                // Ensure our menu EventSystem is enabled&#10;                if (!es.enabled)&#10;                {&#10;                    es.enabled = true;&#10;                    Debug.Log(&quot;[MainMenu] Enabled menu EventSystem&quot;);&#10;                }&#10;                if (!es.gameObject.activeInHierarchy)&#10;                {&#10;                    es.gameObject.SetActive(true);&#10;                    Debug.Log(&quot;[MainMenu] Activated menu EventSystem GameObject&quot;);&#10;                }&#10;            }&#10;            else&#10;            {&#10;                // Temporarily disable other EventSystems to avoid conflicts&#10;                if (es.enabled)&#10;                {&#10;                    es.enabled = false;&#10;                    Debug.Log($&quot;[MainMenu] Disabled gameplay EventSystem: {es.name}&quot;);&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Ensure our EventSystem exists&#10;        if (menuEventSystem == null)&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] Menu EventSystem is null! Recreating...&quot;);&#10;            EnsureEventSystem();&#10;        }&#10;        &#10;        // Make sure the current selected object is cleared to allow button interactions&#10;        if (menuEventSystem != null)&#10;        {&#10;            menuEventSystem.SetSelectedGameObject(null);&#10;        }&#10;        &#10;        // CRITICAL: Disable gameplay camera raycasting&#10;        DisableGameplayCameraRaycasting();&#10;        &#10;        // Ensure input module is properly configured&#10;        SetupInputModule();&#10;        &#10;        // Force enable UI input actions&#10;        if (menuInputModule != null &amp;&amp; uiInputActions != null)&#10;        {&#10;            var uiActionMap = uiInputActions.FindActionMap(&quot;UI&quot;);&#10;            if (uiActionMap != null &amp;&amp; !uiActionMap.enabled)&#10;            {&#10;                uiActionMap.Enable();&#10;                Debug.Log(&quot;[MainMenu] Re-enabled UI input actions&quot;);&#10;            }&#10;        }&#10;    }&#10;    &#10;    private void DisableGameplayCameraRaycasting()&#10;    {&#10;        // Find all cameras and disable their PhysicsRaycaster during menu&#10;        Camera[] allCameras = FindObjectsByType&lt;Camera&gt;(FindObjectsSortMode.None);&#10;        &#10;        foreach (var cam in allCameras)&#10;        {&#10;            // Skip UI/Menu cameras&#10;            if (cam.gameObject.name.Contains(&quot;UI&quot;) || cam.gameObject.name.Contains(&quot;Menu&quot;))&#10;                continue;&#10;            &#10;            // Disable PhysicsRaycaster on gameplay cameras&#10;            var physicsRaycaster = cam.GetComponent&lt;PhysicsRaycaster&gt;();&#10;            if (physicsRaycaster &amp;&amp; physicsRaycaster.enabled)&#10;            {&#10;                physicsRaycaster.enabled = false;&#10;                Debug.Log($&quot;[MainMenu] Disabled PhysicsRaycaster on camera: {cam.name}&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void RestoreGameplayEventSystems()&#10;    {&#10;        // Find all EventSystems and re-enable the gameplay ones&#10;        EventSystem[] allEventSystems = FindObjectsByType&lt;EventSystem&gt;(FindObjectsSortMode.None);&#10;        &#10;        foreach (var es in allEventSystems)&#10;        {&#10;            if (es != menuEventSystem)&#10;            {&#10;                es.enabled = true;&#10;                Debug.Log($&quot;[MainMenu] Re-enabled gameplay EventSystem: {es.name}&quot;);&#10;            }&#10;            else&#10;            {&#10;                // Keep menu EventSystem active but it won't interfere&#10;                Debug.Log(&quot;[MainMenu] Menu EventSystem remains active for future use&quot;);&#10;            }&#10;        }&#10;        &#10;        // Re-enable gameplay camera raycasting&#10;        Camera[] allCameras = FindObjectsByType&lt;Camera&gt;(FindObjectsSortMode.None);&#10;        foreach (var cam in allCameras)&#10;        {&#10;            if (cam.gameObject.name.Contains(&quot;UI&quot;) || cam.gameObject.name.Contains(&quot;Menu&quot;))&#10;                continue;&#10;            &#10;            var physicsRaycaster = cam.GetComponent&lt;UnityEngine.EventSystems.PhysicsRaycaster&gt;();&#10;            if (physicsRaycaster &amp;&amp; !physicsRaycaster.enabled)&#10;            {&#10;                physicsRaycaster.enabled = true;&#10;                Debug.Log($&quot;[MainMenu] Re-enabled PhysicsRaycaster on camera: {cam.name}&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void SetupInputModule()&#10;    {&#10;        if (menuEventSystem == null)&#10;            return;&#10;&#10;        menuInputModule = menuEventSystem.GetComponent&lt;InputSystemUIInputModule&gt;();&#10;        if (menuInputModule == null)&#10;        {&#10;            menuInputModule = menuEventSystem.gameObject.AddComponent&lt;InputSystemUIInputModule&gt;();&#10;        }&#10;&#10;        if (menuInputModule != null &amp;&amp; uiInputActions != null)&#10;        {&#10;            menuInputModule.actionsAsset = uiInputActions;&#10;            &#10;            // Enable the UI input actions so they can receive input&#10;            var uiActionMap = uiInputActions.FindActionMap(&quot;UI&quot;);&#10;            if (uiActionMap != null)&#10;            {&#10;                uiActionMap.Enable();&#10;                Debug.Log(&quot;[MainMenu] UI Input actions enabled for menu interaction&quot;);&#10;            }&#10;        }&#10;        else if (uiInputActions == null)&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] UI Input Actions asset is not assigned! Menu buttons will not be clickable.&quot;);&#10;        }&#10;    }&#10;&#10;    private void SetGameplayInputActive(bool isActive)&#10;    {&#10;        if (playerInput == null &amp;&amp; player)&#10;        {&#10;            playerInput = player.GetComponent&lt;PlayerInput&gt;();&#10;        }&#10;&#10;        if (isActive)&#10;        {&#10;            if (playerInput)&#10;            {&#10;                playerInput.enabled = true;&#10;                playerInput.actions?.Enable();&#10;            }&#10;        }&#10;        else&#10;        {&#10;            // Disable all PlayerInput components to prevent gameplay input during menus&#10;            var allPlayerInputs = FindObjectsByType&lt;PlayerInput&gt;(FindObjectsSortMode.None);&#10;            foreach (var pi in allPlayerInputs)&#10;            {&#10;                if (pi.enabled)&#10;                {&#10;                    pi.actions?.Disable();&#10;                    pi.enabled = false;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private void SetupButtonListeners()&#10;    {&#10;        Debug.Log(&quot;[MainMenu] Setting up button listeners...&quot;);&#10;        &#10;        // Main menu buttons&#10;        if (playButton) &#10;        {&#10;            playButton.onClick.RemoveAllListeners();&#10;            playButton.onClick.AddListener(OnPlayClicked);&#10;            Debug.Log(&quot;[MainMenu] Play button listener added&quot;);&#10;        }&#10;        else Debug.LogWarning(&quot;[MainMenu] Play button is NULL!&quot;);&#10;        &#10;        if (creditsButton)&#10;        {&#10;            creditsButton.onClick.RemoveAllListeners();&#10;            creditsButton.onClick.AddListener(OnCreditsClicked);&#10;        }&#10;        &#10;        if (exitButton)&#10;        {&#10;            exitButton.onClick.RemoveAllListeners();&#10;            exitButton.onClick.AddListener(OnExitClicked);&#10;        }&#10;        &#10;        if (creditsBackButton)&#10;        {&#10;            creditsBackButton.onClick.RemoveAllListeners();&#10;            creditsBackButton.onClick.AddListener(OnBackFromCredits);&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] Credits back button is NULL!&quot;);&#10;        }&#10;        &#10;        if (difficultyBackButton)&#10;        {&#10;            difficultyBackButton.onClick.RemoveAllListeners();&#10;            difficultyBackButton.onClick.AddListener(OnBackFromDifficulty);&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] Difficulty back button is NULL!&quot;);&#10;        }&#10;        &#10;        if (ddaToggle)&#10;        {&#10;            ddaToggle.onValueChanged.RemoveAllListeners();&#10;            ddaToggle.onValueChanged.AddListener(OnDDAToggleChanged);&#10;        }&#10;        &#10;        // Setup difficulty button listeners&#10;        if (easyButton)&#10;        {&#10;            easyButton.onClick.RemoveAllListeners();&#10;            easyButton.onClick.AddListener(() =&gt; OnDifficultySelected(0));&#10;        }&#10;        &#10;        if (mediumButton)&#10;        {&#10;            mediumButton.onClick.RemoveAllListeners();&#10;            mediumButton.onClick.AddListener(() =&gt; OnDifficultySelected(50));&#10;        }&#10;        &#10;        if (hardButton)&#10;        {&#10;            hardButton.onClick.RemoveAllListeners();&#10;            hardButton.onClick.AddListener(() =&gt; OnDifficultySelected(100));&#10;        }&#10;        &#10;        // Setup pause panel button listeners&#10;        if (resumeButton)&#10;        {&#10;            resumeButton.onClick.RemoveAllListeners();&#10;            resumeButton.onClick.AddListener(OnResumeClicked);&#10;            Debug.Log(&quot;[MainMenu] Resume button listener added&quot;);&#10;        }&#10;        else Debug.LogWarning(&quot;[MainMenu] Resume button is NULL!&quot;);&#10;        &#10;        if (pauseExitButton)&#10;        {&#10;            pauseExitButton.onClick.RemoveAllListeners();&#10;            pauseExitButton.onClick.AddListener(OnExitClicked);&#10;        }&#10;        &#10;        // Setup game over panel button listeners&#10;        if (retryButton)&#10;        {&#10;            retryButton.onClick.RemoveAllListeners();&#10;            retryButton.onClick.AddListener(OnRetryClicked);&#10;            Debug.Log(&quot;[MainMenu] Retry button listener added&quot;);&#10;        }&#10;        else Debug.LogWarning(&quot;[MainMenu] Retry button is NULL!&quot;);&#10;        &#10;        if (gameOverExitButton)&#10;        {&#10;            gameOverExitButton.onClick.RemoveAllListeners();&#10;            gameOverExitButton.onClick.AddListener(OnExitClicked);&#10;        }&#10;        &#10;        Debug.Log(&quot;[MainMenu] Button listeners setup complete!&quot;);&#10;    }&#10;&#10;    private void DebugButtonStates()&#10;    {&#10;        Debug.Log(&quot;[MainMenu] === BUTTON DEBUG INFO ===&quot;);&#10;        &#10;        // Check pause panel state&#10;        if (pausePanel)&#10;        {&#10;            Debug.Log($&quot;[MainMenu] Pause Panel: ActiveSelf={pausePanel.activeSelf}, ActiveInHierarchy={pausePanel.activeInHierarchy}&quot;);&#10;        }&#10;        &#10;        if (resumeButton)&#10;        {&#10;            string hierarchy = GetGameObjectPath(resumeButton.gameObject);&#10;            Debug.Log($&quot;[MainMenu] Resume Button: Path='{hierarchy}'&quot;);&#10;            Debug.Log($&quot;[MainMenu] Resume Button: ActiveSelf={resumeButton.gameObject.activeSelf}, &quot; +&#10;                     $&quot;ActiveInHierarchy={resumeButton.gameObject.activeInHierarchy}, &quot; +&#10;                     $&quot;Enabled={resumeButton.enabled}, Interactable={resumeButton.interactable}, &quot; +&#10;                     $&quot;Listeners={resumeButton.onClick.GetPersistentEventCount()}&quot;);&#10;            &#10;            // Check if button's GameObject itself is disabled&#10;            if (!resumeButton.gameObject.activeSelf)&#10;            {&#10;                Debug.LogError($&quot;[MainMenu] &gt;&gt;&gt; RESUME BUTTON GAMEOBJECT IS DISABLED! &lt;&lt;&lt;&quot;);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            Debug.LogError(&quot;[MainMenu] Resume Button reference is NULL!&quot;);&#10;        }&#10;        &#10;        // Check game over panel state&#10;        if (gameOverPanel)&#10;        {&#10;            Debug.Log($&quot;[MainMenu] GameOver Panel: ActiveSelf={gameOverPanel.activeSelf}, ActiveInHierarchy={gameOverPanel.activeInHierarchy}&quot;);&#10;        }&#10;        &#10;        if (retryButton)&#10;        {&#10;            string hierarchy = GetGameObjectPath(retryButton.gameObject);&#10;            Debug.Log($&quot;[MainMenu] Retry Button: Path='{hierarchy}'&quot;);&#10;            Debug.Log($&quot;[MainMenu] Retry Button: ActiveSelf={retryButton.gameObject.activeSelf}, &quot; +&#10;                     $&quot;ActiveInHierarchy={retryButton.gameObject.activeInHierarchy}, &quot; +&#10;                     $&quot;Enabled={retryButton.enabled}, Interactable={retryButton.interactable}, &quot; +&#10;                     $&quot;Listeners={retryButton.onClick.GetPersistentEventCount()}&quot;);&#10;            &#10;            // Check if button's GameObject itself is disabled&#10;            if (!retryButton.gameObject.activeSelf)&#10;            {&#10;                Debug.LogError($&quot;[MainMenu] &gt;&gt;&gt; RETRY BUTTON GAMEOBJECT IS DISABLED! &lt;&lt;&lt;&quot;);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            Debug.LogError(&quot;[MainMenu] Retry Button reference is NULL!&quot;);&#10;        }&#10;        &#10;        if (pauseExitButton)&#10;        {&#10;            Debug.Log($&quot;[MainMenu] Pause Exit Button: ActiveInHierarchy={pauseExitButton.gameObject.activeInHierarchy}, &quot; +&#10;                     $&quot;Enabled={pauseExitButton.enabled}, Interactable={pauseExitButton.interactable}&quot;);&#10;        }&#10;        &#10;        if (gameOverExitButton)&#10;        {&#10;            Debug.Log($&quot;[MainMenu] GameOver Exit Button: ActiveInHierarchy={gameOverExitButton.gameObject.activeInHierarchy}, &quot; +&#10;                     $&quot;Enabled={gameOverExitButton.enabled}, Interactable={gameOverExitButton.interactable}&quot;);&#10;        }&#10;    }&#10;    &#10;    private string GetGameObjectPath(GameObject obj)&#10;    {&#10;        string path = obj.name;&#10;        Transform current = obj.transform.parent;&#10;        while (current != null)&#10;        {&#10;            path = current.name + &quot;/&quot; + path;&#10;            current = current.parent;&#10;        }&#10;        return path;&#10;    }&#10;&#10;    private void ForceEnableButtons()&#10;    {&#10;        Debug.Log(&quot;[MainMenu] === FORCE ENABLING BUTTONS ===&quot;);&#10;        &#10;        // ONLY process the panel that is CURRENTLY ACTIVE - don't activate inactive ones!&#10;        &#10;        // If pause panel is active, fix its buttons and CanvasGroup&#10;        if (pausePanel &amp;&amp; pausePanel.activeSelf)&#10;        {&#10;            Debug.Log(&quot;[MainMenu] Processing Pause Panel buttons (panel is active)&quot;);&#10;            &#10;            // Check for CanvasGroup that might be blocking interaction&#10;            var canvasGroup = pausePanel.GetComponent&lt;CanvasGroup&gt;();&#10;            if (canvasGroup)&#10;            {&#10;                if (!canvasGroup.interactable)&#10;                {&#10;                    Debug.LogWarning($&quot;[MainMenu] Pause Panel has CanvasGroup with interactable=false! Enabling it...&quot;);&#10;                    canvasGroup.interactable = true;&#10;                }&#10;                if (canvasGroup.blocksRaycasts == false)&#10;                {&#10;                    Debug.LogWarning($&quot;[MainMenu] Pause Panel CanvasGroup blocksRaycasts=false! Enabling it...&quot;);&#10;                    canvasGroup.blocksRaycasts = true;&#10;                }&#10;            }&#10;            &#10;            // Force enable pause panel buttons ONLY&#10;            if (resumeButton &amp;&amp; !resumeButton.gameObject.activeSelf)&#10;            {&#10;                Debug.LogWarning($&quot;[MainMenu] Resume button GameObject was disabled! Enabling it now...&quot;);&#10;                resumeButton.gameObject.SetActive(true);&#10;            }&#10;            &#10;            if (pauseExitButton &amp;&amp; !pauseExitButton.gameObject.activeSelf)&#10;            {&#10;                Debug.LogWarning($&quot;[MainMenu] Pause Exit button GameObject was disabled! Enabling it now...&quot;);&#10;                pauseExitButton.gameObject.SetActive(true);&#10;            }&#10;            &#10;        }&#10;        else if (pausePanel)&#10;        {&#10;            Debug.Log(&quot;[MainMenu] Pause Panel exists but is INACTIVE - skipping button processing&quot;);&#10;        }&#10;        &#10;        // If game over panel is active, fix its buttons and CanvasGroup&#10;        if (gameOverPanel &amp;&amp; gameOverPanel.activeSelf)&#10;        {&#10;            Debug.Log(&quot;[MainMenu] Processing GameOver Panel buttons (panel is active)&quot;);&#10;            &#10;            // Check for CanvasGroup that might be blocking interaction&#10;            var canvasGroup = gameOverPanel.GetComponent&lt;CanvasGroup&gt;();&#10;            if (canvasGroup)&#10;            {&#10;                if (!canvasGroup.interactable)&#10;                {&#10;                    Debug.LogWarning($&quot;[MainMenu] GameOver Panel has CanvasGroup with interactable=false! Enabling it...&quot;);&#10;                    canvasGroup.interactable = true;&#10;                }&#10;                if (canvasGroup.blocksRaycasts == false)&#10;                {&#10;                    Debug.LogWarning($&quot;[MainMenu] GameOver Panel CanvasGroup blocksRaycasts=false! Enabling it...&quot;);&#10;                    canvasGroup.blocksRaycasts = true;&#10;                }&#10;            }&#10;            &#10;            // Force enable game over panel buttons ONLY&#10;            if (retryButton &amp;&amp; !retryButton.gameObject.activeSelf)&#10;            {&#10;                Debug.LogWarning($&quot;[MainMenu] Retry button GameObject was disabled! Enabling it now...&quot;);&#10;                retryButton.gameObject.SetActive(true);&#10;            }&#10;            &#10;            if (gameOverExitButton &amp;&amp; !gameOverExitButton.gameObject.activeSelf)&#10;            {&#10;                Debug.LogWarning($&quot;[MainMenu] GameOver Exit button GameObject was disabled! Enabling it now...&quot;);&#10;                gameOverExitButton.gameObject.SetActive(true);&#10;            }&#10;        }&#10;        else if (gameOverPanel)&#10;        {&#10;            Debug.Log(&quot;[MainMenu] GameOver Panel exists but is INACTIVE - skipping button processing&quot;);&#10;        }&#10;    }&#10;    &#10;&#10;&#10;    private void CheckGraphicRaycaster()&#10;    {&#10;        Debug.Log(&quot;[MainMenu] === CANVAS RAYCASTER CHECK ===&quot;);&#10;        &#10;        // Get the canvas root&#10;        Transform canvasRoot = transform;&#10;        while (canvasRoot.parent != null)&#10;        {&#10;            canvasRoot = canvasRoot.parent;&#10;        }&#10;        &#10;        var canvas = canvasRoot.GetComponent&lt;Canvas&gt;();&#10;        if (canvas)&#10;        {&#10;            Debug.Log($&quot;[MainMenu] Canvas found: {canvas.name}&quot;);&#10;            &#10;            var raycaster = canvas.GetComponent&lt;UnityEngine.UI.GraphicRaycaster&gt;();&#10;            if (raycaster)&#10;            {&#10;                Debug.Log($&quot;[MainMenu] GraphicRaycaster FOUND: Enabled={raycaster.enabled}, &quot; +&#10;                         $&quot;IgnoreReversedGraphics={raycaster.ignoreReversedGraphics}&quot;);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogError(&quot;[MainMenu] GraphicRaycaster MISSING! Adding it now...&quot;);&#10;                raycaster = canvas.gameObject.AddComponent&lt;UnityEngine.UI.GraphicRaycaster&gt;();&#10;                Debug.Log(&quot;[MainMenu] GraphicRaycaster added to Canvas!&quot;);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            Debug.LogError(&quot;[MainMenu] Canvas component not found!&quot;);&#10;        }&#10;        &#10;        // Check EventSystem&#10;        if (menuEventSystem)&#10;        {&#10;            Debug.Log($&quot;[MainMenu] EventSystem: Enabled={menuEventSystem.enabled}, &quot; +&#10;                     $&quot;CurrentSelected={menuEventSystem.currentSelectedGameObject}&quot;);&#10;            &#10;            if (menuInputModule)&#10;            {&#10;                Debug.Log($&quot;[MainMenu] InputModule: Enabled={menuInputModule.enabled}, &quot; +&#10;                         $&quot;ActionsAsset={(menuInputModule.actionsAsset != null ? &quot;Assigned&quot; : &quot;NULL&quot;)}&quot;);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogError(&quot;[MainMenu] InputModule is NULL!&quot;);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            Debug.LogError(&quot;[MainMenu] EventSystem is NULL!&quot;);&#10;        }&#10;    }&#10;&#10;    private void CacheTextElements()&#10;    {&#10;        // Find all GameObjects with MainPanelElement tag&#10;        try&#10;        {&#10;            mainPanelTextElements = GameObject.FindGameObjectsWithTag(&quot;MainPanelElement&quot;);&#10;            Debug.Log($&quot;[MainMenu] Found {mainPanelTextElements.Length} text elements with MainPanelElement tag&quot;);&#10;        }&#10;        catch (UnityException)&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] Tag 'MainPanelElement' not defined in Tags and Layers. Please add it in Project Settings &gt; Tags and Layers&quot;);&#10;            mainPanelTextElements = new GameObject[0];&#10;        }&#10;&#10;        // Find all GameObjects with DifficultyElement tag&#10;        try&#10;        {&#10;            difficultyPanelTextElements = GameObject.FindGameObjectsWithTag(&quot;DifficultyElement&quot;);&#10;            Debug.Log($&quot;[MainMenu] Found {difficultyPanelTextElements.Length} text elements with DifficultyElement tag&quot;);&#10;        }&#10;        catch (UnityException)&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] Tag 'DifficultyElement' not defined in Tags and Layers. Please add it in Project Settings &gt; Tags and Layers&quot;);&#10;            difficultyPanelTextElements = new GameObject[0];&#10;        }&#10;&#10;        // Find all GameObjects with CreditsPanelElement tag&#10;        try&#10;        {&#10;            creditsPanelTextElements = GameObject.FindGameObjectsWithTag(&quot;CreditsPanelElement&quot;);&#10;            Debug.Log($&quot;[MainMenu] Found {creditsPanelTextElements.Length} text elements with CreditsPanelElement tag&quot;);&#10;        }&#10;        catch (UnityException)&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] Tag 'CreditsPanelElement' not defined in Tags and Layers. Please add it in Project Settings &gt; Tags and Layers&quot;);&#10;            creditsPanelTextElements = new GameObject[0];&#10;        }&#10;    }&#10;&#10;    private void ShowMainPanelText()&#10;    {&#10;        // Show MainPanel text elements&#10;        if (mainPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in mainPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(true);&#10;                }&#10;            }&#10;            Debug.Log($&quot;[MainMenu] Showed {mainPanelTextElements.Length} MainPanel text elements&quot;);&#10;        }&#10;&#10;        // Hide DifficultyPanel text elements&#10;        if (difficultyPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in difficultyPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(false);&#10;                }&#10;            }&#10;        }&#10;        &#10;        if (creditsPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in creditsPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(false);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private void ShowDifficultyPanelText()&#10;    {&#10;        // Hide MainPanel text elements&#10;        if (mainPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in mainPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(false);&#10;                }&#10;            }&#10;        }&#10;&#10;        // Show DifficultyPanel text elements&#10;        if (difficultyPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in difficultyPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(true);&#10;                }&#10;            }&#10;            Debug.Log($&quot;[MainMenu] Showed {difficultyPanelTextElements.Length} DifficultyPanel text elements&quot;);&#10;        }&#10;        &#10;        if (creditsPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in creditsPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(false);&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    private void ShowCreditsPanelText()&#10;    {&#10;        if (mainPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in mainPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(false);&#10;                }&#10;            }&#10;        }&#10;        &#10;        if (difficultyPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in difficultyPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(false);&#10;                }&#10;            }&#10;        }&#10;        &#10;        if (creditsPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in creditsPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(true);&#10;                }&#10;            }&#10;            Debug.Log($&quot;[MainMenu] Showed {creditsPanelTextElements.Length} CreditsPanel text elements&quot;);&#10;        }&#10;    }&#10;&#10;    private void HideAllPanelText()&#10;    {&#10;        // Hide all text elements when no panel is showing&#10;        if (mainPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in mainPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(false);&#10;                }&#10;            }&#10;        }&#10;&#10;        if (difficultyPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in difficultyPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(false);&#10;                }&#10;            }&#10;        }&#10;        &#10;        if (creditsPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in creditsPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(false);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private void EnsureCanvasConfiguration()&#10;    {&#10;        // Get the canvas root&#10;        Transform canvasRoot = transform;&#10;        while (canvasRoot.parent != null)&#10;        {&#10;            canvasRoot = canvasRoot.parent;&#10;        }&#10;&#10;        var canvas = canvasRoot.GetComponent&lt;Canvas&gt;();&#10;        if (canvas == null)&#10;        {&#10;            Debug.LogError(&quot;[MainMenu] Canvas component not found on root!&quot;);&#10;            return;&#10;        }&#10;&#10;        Debug.Log($&quot;[MainMenu] Ensuring Canvas configuration - RenderMode: {canvas.renderMode}&quot;);&#10;&#10;        // Ensure Canvas has GraphicRaycaster&#10;        var raycaster = canvas.GetComponent&lt;GraphicRaycaster&gt;();&#10;        if (raycaster == null)&#10;        {&#10;            raycaster = canvas.gameObject.AddComponent&lt;GraphicRaycaster&gt;();&#10;            Debug.Log(&quot;[MainMenu] Added GraphicRaycaster to Canvas&quot;);&#10;        }&#10;        raycaster.enabled = true;&#10;&#10;        // If using Screen Space - Camera, ensure camera is assigned&#10;        if (canvas.renderMode == RenderMode.ScreenSpaceCamera &amp;&amp; canvas.worldCamera == null)&#10;        {&#10;            canvas.worldCamera = Camera.main;&#10;            Debug.Log(&quot;[MainMenu] Assigned Main Camera to Canvas&quot;);&#10;        }&#10;&#10;        // Set canvas to render on top&#10;        canvas.sortingOrder = 1000;&#10;        Debug.Log($&quot;[MainMenu] Canvas configured - Raycaster enabled, SortingOrder: {canvas.sortingOrder}&quot;);&#10;    }&#10;&#10;    private void ConfigureDecorativeOverlays()&#10;    {&#10;        if (nonBlockingGraphics != null)&#10;        {&#10;            foreach (var graphic in nonBlockingGraphics)&#10;            {&#10;                if (!graphic)&#10;                {&#10;                    continue;&#10;                }&#10;                if (graphic.raycastTarget)&#10;                {&#10;                    graphic.raycastTarget = false;&#10;                    Debug.Log($&quot;[MainMenu] Disabled raycast target on decor graphic '{graphic.name}'&quot;);&#10;                }&#10;            }&#10;        }&#10;        &#10;        if (nonBlockingCanvasGroups != null)&#10;        {&#10;            foreach (var canvasGroup in nonBlockingCanvasGroups)&#10;            {&#10;                if (!canvasGroup)&#10;                {&#10;                    continue;&#10;                }&#10;                if (canvasGroup.blocksRaycasts)&#10;                {&#10;                    canvasGroup.blocksRaycasts = false;&#10;                    Debug.Log($&quot;[MainMenu] Disabled raycast blocking on decor CanvasGroup '{canvasGroup.name}'&quot;);&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    #region Audio Management&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Mutes all gameplay audio sources (lasers, footsteps, etc.)&#10;    /// &lt;/summary&gt;&#10;    private void MuteGameplayAudio()&#10;    {&#10;        if (gameplayAudioMuted) return;&#10;        &#10;        Debug.LogWarning(&quot;[MainMenu] Muting gameplay audio&quot;);&#10;        gameplayAudioMuted = true;&#10;        &#10;        // Find and mute all AudioSources in the gameplay scene&#10;        AudioSource[] allAudioSources = FindObjectsByType&lt;AudioSource&gt;(FindObjectsInactive.Include, FindObjectsSortMode.None);&#10;        foreach (AudioSource audioSource in allAudioSources)&#10;        {&#10;            // Skip the menu music source&#10;            if (audioSource == menuMusicSource) continue;&#10;            &#10;            // Mute gameplay audio sources&#10;            if (audioSource.gameObject.scene.name == gameplaySceneName || &#10;                audioSource.CompareTag(gameplayAudioTag))&#10;            {&#10;                audioSource.mute = true;&#10;            }&#10;        }&#10;        ToggleGameMusicWithFade(false);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Unmutes all gameplay audio sources and restores volumes to 1.0&#10;    /// &lt;/summary&gt;&#10;    private void UnmuteGameplayAudio()&#10;    {&#10;        if (!gameplayAudioMuted) return;&#10;        &#10;        Debug.LogWarning(&quot;[MainMenu] Unmuting gameplay audio&quot;);&#10;        gameplayAudioMuted = false;&#10;        &#10;        // Find and unmute all AudioSources in the gameplay scene&#10;        AudioSource[] allAudioSources = FindObjectsByType&lt;AudioSource&gt;(FindObjectsInactive.Include, FindObjectsSortMode.None);&#10;        foreach (AudioSource audioSource in allAudioSources)&#10;        {&#10;            // Skip the menu music source&#10;            if (audioSource == menuMusicSource) continue;&#10;            &#10;            // Unmute gameplay audio sources and restore volume&#10;            if (audioSource.gameObject.scene.name == gameplaySceneName || &#10;                audioSource.CompareTag(gameplayAudioTag))&#10;            {&#10;                audioSource.mute = false;&#10;                // Restore volume to full (in case it was faded out)&#10;                if (audioSource.volume &lt; 0.1f)&#10;                {&#10;                    audioSource.volume = 1f;&#10;                }&#10;            }&#10;        }&#10;        ToggleGameMusicWithFade(true);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Toggles the gameplay music on or off with a fade effect.&#10;    /// &lt;/summary&gt;&#10;    void ToggleGameMusicWithFade(bool state)&#10;    {&#10;        if (gameplayMusicSource == null) &#10;        { &#10;            Debug.LogWarning(&quot;[MainMenu] Gameplay music source is NULL, cannot toggle music&quot;);&#10;            return;&#10;        }&#10;&#10;        if (gameplayAudioFadeCoroutine != null)&#10;        {&#10;            StopCoroutine(gameplayAudioFadeCoroutine);&#10;            gameplayAudioFadeCoroutine = null;&#10;        }&#10;        &#10;        Debug.LogWarning(&quot;[MainMenu] Toggling gameplay music with fade-in&quot;);&#10;        if (state)&#10;        {&#10;            gameplayAudioFadeCoroutine = StartCoroutine(FadeInMusic(gameplayMusicSource, musicFadeInDuration, isGameOverMusic: false));&#10;        }&#10;        else&#10;        {&#10;            gameplayAudioFadeCoroutine = StartCoroutine(FadeOutMusic(gameplayMusicSource, musicFadeOutDuration, isGameOverMusic: false, false));&#10;        }&#10;    }&#10;&#10;    void BeginGameMusic()&#10;    {&#10;        gameStarted = true;&#10;        ToggleGameMusicWithFade(true);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Starts playing menu music if available&#10;    /// &lt;/summary&gt;&#10;    private void PlayMenuMusic()&#10;    {&#10;        if (menuMusicSource != null &amp;&amp; !menuMusicSource.isPlaying)&#10;        {&#10;            menuMusicSource.Play();&#10;            Debug.Log(&quot;[MainMenu] Started menu music&quot;);&#10;        }&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Stops playing menu music&#10;    /// &lt;/summary&gt;&#10;    private void StopMenuMusic()&#10;    {&#10;        if (menuMusicSource != null &amp;&amp; menuMusicSource.isPlaying)&#10;        {&#10;            menuMusicSource.Stop();&#10;            Debug.Log(&quot;[MainMenu] Stopped menu music&quot;);&#10;        }&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Fades in pause music over the specified duration&#10;    /// &lt;/summary&gt;&#10;    private void PlayPauseMusicWithFadeIn()&#10;    {&#10;        if (pauseMusicSource == null) return;&#10;&#10;        // Stop any current pause music fade&#10;        if (pauseMusicFadeCoroutine != null)&#10;        {&#10;            StopCoroutine(pauseMusicFadeCoroutine);&#10;            pauseMusicFadeCoroutine = null;&#10;        }&#10;        &#10;        pauseMusicFadeCoroutine = StartCoroutine(FadeInMusic(pauseMusicSource, musicFadeInDuration, isGameOverMusic: false));&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Fades out pause music over the specified duration&#10;    /// &lt;/summary&gt;&#10;    private void StopPauseMusicWithFadeOut()&#10;    {&#10;        if (pauseMusicSource == null) return;&#10;&#10;        // Stop any current pause music fade&#10;        if (pauseMusicFadeCoroutine != null)&#10;        {&#10;            StopCoroutine(pauseMusicFadeCoroutine);&#10;            pauseMusicFadeCoroutine = null;&#10;        }&#10;        &#10;        pauseMusicFadeCoroutine = StartCoroutine(FadeOutMusic(pauseMusicSource, musicFadeOutDuration, isGameOverMusic: false));&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Fades in game over music after a delay&#10;    /// &lt;/summary&gt;&#10;    private void PlayGameOverMusicWithFadeIn()&#10;    {&#10;        if (gameOverMusicSource == null) return;&#10;&#10;        // Stop any current game over music fade&#10;        if (gameOverMusicFadeCoroutine != null)&#10;        {&#10;            StopCoroutine(gameOverMusicFadeCoroutine);&#10;            gameOverMusicFadeCoroutine = null;&#10;        }&#10;        &#10;        gameOverMusicFadeCoroutine = StartCoroutine(PlayGameOverMusicWithDelayCoroutine());&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Coroutine to delay then fade in game over music&#10;    /// &lt;/summary&gt;&#10;    private System.Collections.IEnumerator PlayGameOverMusicWithDelayCoroutine()&#10;    {&#10;        Debug.Log($&quot;[MainMenu] Waiting {gameOverMusicDelay} seconds before fading in game over music&quot;);&#10;        yield return new WaitForSecondsRealtime(gameOverMusicDelay);&#10;        if (gameOverMusicSource != null)&#10;        {&#10;            Debug.Log(&quot;[MainMenu] Starting game over music fade-in&quot;);&#10;            yield return FadeInMusic(gameOverMusicSource, musicFadeInDuration, isGameOverMusic: true);&#10;        }&#10;        &#10;        gameOverMusicFadeCoroutine = null;&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Fades out game over music over the specified duration&#10;    /// &lt;/summary&gt;&#10;    private void StopGameOverMusicWithFadeOut()&#10;    {&#10;        if (gameOverMusicSource == null) return;&#10;&#10;        // Stop any current game over music fade&#10;        if (gameOverMusicFadeCoroutine != null)&#10;        {&#10;            StopCoroutine(gameOverMusicFadeCoroutine);&#10;            gameOverMusicFadeCoroutine = null;&#10;        }&#10;        &#10;        gameOverMusicFadeCoroutine = StartCoroutine(FadeOutMusic(gameOverMusicSource, musicFadeOutDuration, isGameOverMusic: true));&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Coroutine to fade in an audio source&#10;    /// &lt;/summary&gt;&#10;    private System.Collections.IEnumerator FadeInMusic(AudioSource audioSource, float duration, bool isGameOverMusic)&#10;    {&#10;        if (audioSource == null) yield break;&#10;        &#10;        Debug.Log($&quot;[MainMenu] Fading in {audioSource.name} over {duration} seconds&quot;);&#10;        &#10;        // Start playing if not already&#10;        if (!audioSource.isPlaying)&#10;        {&#10;            audioSource.volume = 0f;&#10;            audioSource.Play();&#10;        }&#10;        &#10;        float startVolume = audioSource.volume;&#10;        float targetVolume = 0.4f; // was 1f, but it was too loud&#10;        float elapsed = 0f;&#10;        &#10;        while (elapsed &lt; duration)&#10;        {&#10;            elapsed += Time.unscaledDeltaTime;&#10;            float fadeProgress = elapsed / duration;&#10;            audioSource.volume = Mathf.Lerp(startVolume, targetVolume, fadeProgress);&#10;            yield return null;&#10;        }&#10;        &#10;        audioSource.volume = targetVolume;&#10;        Debug.Log($&quot;[MainMenu] Fade in complete for {audioSource.name}&quot;);&#10;        &#10;        // Clear the tracking reference&#10;        if (isGameOverMusic)&#10;            gameOverMusicFadeCoroutine = null;&#10;        else&#10;            pauseMusicFadeCoroutine = null;&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Coroutine to fade out an audio source&#10;    /// &lt;/summary&gt;&#10;    private System.Collections.IEnumerator FadeOutMusic(AudioSource audioSource, float duration, bool isGameOverMusic, bool stopMusic = true)&#10;    {&#10;        if (audioSource == null) yield break;&#10;        &#10;        Debug.Log($&quot;[MainMenu] Fading out {audioSource.name} over {duration} seconds - start volume: {audioSource.volume}&quot;);&#10;        &#10;        float startVolume = audioSource.volume;&#10;        float targetVolume = 0f;&#10;        float elapsed = 0f;&#10;        &#10;        while (elapsed &lt; duration)&#10;        {&#10;            elapsed += Time.unscaledDeltaTime;&#10;            float fadeProgress = elapsed / duration;&#10;            audioSource.volume = Mathf.Lerp(startVolume, targetVolume, fadeProgress);&#10;            Debug.Log($&quot;[MainMenu] Fade out progress: {fadeProgress:F2}, volume: {audioSource.volume:F2}&quot;);&#10;            yield return null;&#10;        }&#10;        &#10;        audioSource.volume = targetVolume;&#10;        if(stopMusic)&#10;        {&#10;            audioSource.Stop();&#10;        }&#10;&#10;        Debug.Log($&quot;[MainMenu] Fade out complete for {audioSource.name}&quot;);&#10;        &#10;        // Clear the tracking reference&#10;        if (isGameOverMusic)&#10;            gameOverMusicFadeCoroutine = null;&#10;        else&#10;            pauseMusicFadeCoroutine = null;&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Unmute gameplay audio after a delay (for retry functionality)&#10;    /// &lt;/summary&gt;&#10;    private System.Collections.IEnumerator UnmuteGameplayAudioDelayed(float delay)&#10;    {&#10;        Debug.Log($&quot;[MainMenu] Delaying gameplay audio unmute by {delay} seconds&quot;);&#10;        yield return new WaitForSecondsRealtime(delay);&#10;        UnmuteGameplayAudio();&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Mute gameplay audio after a delay with fade-out effect (for when player is caught)&#10;    /// &lt;/summary&gt;&#10;    private System.Collections.IEnumerator MuteGameplayAudioDelayed(float delay)&#10;    {&#10;        Debug.Log($&quot;[MainMenu] Fading out gameplay audio over {delay} seconds&quot;);&#10;        &#10;        // Find all gameplay audio sources&#10;        AudioSource[] allAudioSources = FindObjectsByType&lt;AudioSource&gt;(FindObjectsInactive.Include, FindObjectsSortMode.None);&#10;        &#10;        // Store original volumes and filter to gameplay sources only&#10;        System.Collections.Generic.List&lt;AudioSource&gt; gameplayAudioSources = new System.Collections.Generic.List&lt;AudioSource&gt;();&#10;        System.Collections.Generic.Dictionary&lt;AudioSource, float&gt; originalVolumes = new System.Collections.Generic.Dictionary&lt;AudioSource, float&gt;();&#10;        &#10;        foreach (AudioSource audioSource in allAudioSources)&#10;        {&#10;            // Skip the menu music source&#10;            if (audioSource == menuMusicSource) continue;&#10;            &#10;            // Only include gameplay audio sources&#10;            if (audioSource.gameObject.scene.name == gameplaySceneName || &#10;                audioSource.CompareTag(gameplayAudioTag))&#10;            {&#10;                gameplayAudioSources.Add(audioSource);&#10;                originalVolumes[audioSource] = audioSource.volume;&#10;            }&#10;        }&#10;        &#10;        // Fade out over the delay duration&#10;        float elapsed = 0f;&#10;        while (elapsed &lt; delay)&#10;        {&#10;            elapsed += Time.unscaledDeltaTime; // Use unscaledDeltaTime in case game is paused&#10;            float fadeProgress = elapsed / delay; // 0 to 1&#10;            float volumeMultiplier = 1f - fadeProgress; // 1 to 0&#10;            &#10;            // Apply fade to all gameplay audio sources&#10;            foreach (AudioSource audioSource in gameplayAudioSources)&#10;            {&#10;                if (audioSource != null &amp;&amp; originalVolumes.ContainsKey(audioSource))&#10;                {&#10;                    audioSource.volume = originalVolumes[audioSource] * volumeMultiplier;&#10;                }&#10;            }&#10;            if (!isRetrying)&#10;            {&#10;                yield break; // Exit early if player is retrying&#10;            }&#10;            yield return null; // Wait one frame&#10;        }&#10;        &#10;        // Ensure all volumes are at 0 and mute them&#10;        foreach (AudioSource audioSource in gameplayAudioSources)&#10;        {&#10;            if (audioSource != null)&#10;            {&#10;                audioSource.volume = 0f;&#10;            }&#10;        }&#10;        &#10;        // Finally, mute all gameplay audio&#10;        MuteGameplayAudio();&#10;        &#10;        Debug.Log(&quot;[MainMenu] Gameplay audio fade-out complete&quot;);&#10;    }&#10;    &#10;    #endregion&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.UI;&#10;using TMPro;&#10;using Assets.Scripts.DDA;&#10;using UnityEngine.SceneManagement;&#10;using UnityEngine.EventSystems;&#10;using UnityEngine.InputSystem;&#10;using UnityEngine.InputSystem.UI;&#10;using System;&#10;using System.Collections;&#10;&#10;public class MainMenu : MonoBehaviour&#10;{&#10;    [Header(&quot;UI Panels&quot;)]&#10;    [SerializeField] private GameObject mainPanel;&#10;    [SerializeField] private GameObject creditsPanel;&#10;    [SerializeField] private GameObject difficultyPanel;&#10;    [SerializeField] private GameObject pausePanel;&#10;    [SerializeField] private GameObject gameOverPanel;&#10;    &#10;    [Header(&quot;Main Panel Buttons&quot;)]&#10;    [SerializeField] private Button playButton;&#10;    [SerializeField] private Button creditsButton;&#10;    [SerializeField] private Button exitButton;&#10;    [SerializeField] private Toggle ddaToggle;&#10;    &#10;    [Header(&quot;Difficulty Panel Buttons&quot;)]&#10;    [SerializeField] private Button easyButton;&#10;    [SerializeField] private Button mediumButton;&#10;    [SerializeField] private Button hardButton;&#10;    [SerializeField] private Button difficultyBackButton;&#10;    &#10;    [Header(&quot;Credits Panel Buttons&quot;)]&#10;    [SerializeField] private Button creditsBackButton;&#10;    &#10;    [Header(&quot;Pause Panel Buttons&quot;)]&#10;    [SerializeField] private Button resumeButton;&#10;    [SerializeField] private Button pauseExitButton;&#10;    &#10;    &#10;    [Header(&quot;Game Over Panel Buttons&quot;)]&#10;    [SerializeField] private Button retryButton;&#10;    [SerializeField] private Button gameOverExitButton;&#10;&#10;    [Header(&quot;Gameplay UI&quot;)]&#10;    [SerializeField] private GameObject gameplayCanvas;&#10;&#10;    [Header(&quot;Settings&quot;)]&#10;    [SerializeField] private bool showOnStart = true;&#10;    [SerializeField] private string playerTag = &quot;Player&quot;;&#10;    [SerializeField] private string mainMenuSceneName = &quot;MainMenu&quot;;&#10;    [SerializeField] private string gameplaySceneName = &quot;Jakob&quot;;&#10;    &#10;    [Header(&quot;Input&quot;)]&#10;    [SerializeField] private InputActionAsset uiInputActions;&#10;    &#10;    [Header(&quot;Decor Overlays&quot;)]&#10;    [SerializeField] private Graphic[] nonBlockingGraphics;&#10;    [SerializeField] private CanvasGroup[] nonBlockingCanvasGroups;&#10;    &#10;    [Header(&quot;Audio&quot;)]&#10;    [SerializeField] private AudioSource menuMusicSource;&#10;    [SerializeField] private AudioSource gameplayMusicSource;&#10;    [SerializeField] private AudioSource pauseMusicSource;&#10;    [SerializeField] private AudioSource gameOverMusicSource;&#10;    [SerializeField] private float retryAudioDelay = 1.5f;&#10;    [SerializeField] private float muteAudioDelay = 4f;&#10;    [SerializeField] private float musicFadeInDuration = 4f;&#10;    [SerializeField] private float musicFadeOutDuration = 1f;&#10;    [SerializeField] private float gameOverMusicDelay = 2f;&#10;    [Tooltip(&quot;Tag to find all gameplay audio sources&quot;)]&#10;    [SerializeField] private string gameplayAudioTag = &quot;GameplayAudio&quot;;&#10;    &#10;    private bool gameplayAudioMuted = false;&#10;    private Coroutine pauseMusicFadeCoroutine = null;&#10;    private Coroutine gameOverMusicFadeCoroutine = null;&#10;    private Coroutine gameplayAudioFadeCoroutine = null;&#10;&#10;    // Cached text elements by tag&#10;    private GameObject[] mainPanelTextElements;&#10;    private GameObject[] difficultyPanelTextElements;&#10;    private GameObject[] creditsPanelTextElements;&#10;&#10;    private GameObject player;&#10;    private bool isGamePaused;&#10;    private bool isGameOver;&#10;    private bool isRetrying; // Track if we're currently in a retry flow&#10;    private bool isTransitioningToGameplay;&#10;    private EventSystem menuEventSystem;&#10;    private PlayerInput playerInput;&#10;    private InputSystemUIInputModule menuInputModule;&#10;&#10;    public static MainMenu Instance { get; private set; }&#10;&#10;    private bool IsGameplaySceneLoaded =&gt; SceneManager.GetSceneByName(gameplaySceneName).isLoaded;&#10;&#10;    bool gameStarted = false;&#10;&#10;    public static Action fadeToGameplayScene;&#10;    public static void OnFadeToGameplayScene() =&gt; fadeToGameplayScene?.Invoke();&#10;&#10;&#10;    private void Awake()&#10;    {&#10;        if (Instance == null)&#10;        {&#10;            Instance = this;&#10;            &#10;            // Make the entire canvas hierarchy persistent (not just this script object)&#10;            // Find the root canvas object&#10;            Transform canvasRoot = transform;&#10;            while (canvasRoot.parent != null)&#10;            {&#10;                canvasRoot = canvasRoot.parent;&#10;            }&#10;            &#10;            // Ensure it's at root and make it persistent&#10;            canvasRoot.SetParent(null);&#10;            DontDestroyOnLoad(canvasRoot.gameObject);&#10;            &#10;            Debug.Log($&quot;[MainMenu] Made {canvasRoot.name} persistent across scenes&quot;);&#10;            &#10;            EnsureEventSystem();&#10;        }&#10;        else&#10;        {&#10;            Destroy(gameObject);&#10;        }&#10;    }&#10;&#10;    private void OnEnable()&#10;    {&#10;        SceneManager.sceneLoaded += OnSceneLoaded;&#10;        // Subscribe to checkpoint load completion&#10;        CheckpointManager.loadCheckpoint += OnCheckpointLoaded;&#10;        ObjectivesManager.objectiveStarted += BeginGameMusic;&#10;        PlayerActions.playerEscaped += OnPlayerEscapedDisableGameplayMusic;&#10;    }&#10;&#10;    private void OnDisable()&#10;    {&#10;        SceneManager.sceneLoaded -= OnSceneLoaded;&#10;        ObjectivesManager.objectiveStarted -= BeginGameMusic;&#10;        PlayerActions.playerEscaped -= OnPlayerEscapedDisableGameplayMusic;&#10;    }&#10;&#10;    private void OnPlayerEscapedDisableGameplayMusic()&#10;    {&#10;        if (gameplayMusicSource)&#10;        {&#10;            gameplayMusicSource.enabled = false;&#10;        }&#10;    }&#10;&#10;    private void Start()&#10;    {&#10;        Debug.Log($&quot;[MainMenu] ========== START CALLED on {gameObject.name} ==========&quot;);&#10;        Debug.Log($&quot;[MainMenu] Instance check - This: {this.GetInstanceID()}, Singleton: {Instance?.GetInstanceID()}&quot;);&#10;&#10;        // FIRST: Immediately hide all secondary panels to ensure clean state&#10;        // This must happen before any other logic to prevent overlapping UI&#10;        Debug.Log($&quot;[MainMenu] Panel references - Main: {mainPanel != null}, Credits: {creditsPanel != null}, Difficulty: {difficultyPanel != null}, Pause: {pausePanel != null}, GameOver: {gameOverPanel != null}&quot;);&#10;&#10;        if (creditsPanel)&#10;        {&#10;            creditsPanel.SetActive(false);&#10;            Debug.Log($&quot;[MainMenu] CreditsPanel deactivated - Active: {creditsPanel.activeSelf}&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] CreditsPanel reference is NULL!&quot;);&#10;        }&#10;&#10;        if (difficultyPanel)&#10;        {&#10;            difficultyPanel.SetActive(false);&#10;            Debug.Log($&quot;[MainMenu] DifficultyPanel deactivated - Active: {difficultyPanel.activeSelf}&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] DifficultyPanel reference is NULL!&quot;);&#10;        }&#10;&#10;        if (pausePanel)&#10;        {&#10;            pausePanel.SetActive(false);&#10;            Debug.Log($&quot;[MainMenu] PausePanel deactivated - Active: {pausePanel.activeSelf}&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] PausePanel reference is NULL!&quot;);&#10;        }&#10;&#10;        if (gameOverPanel)&#10;        {&#10;            gameOverPanel.SetActive(false);&#10;            Debug.Log($&quot;[MainMenu] GameOverPanel deactivated - Active: {gameOverPanel.activeSelf}&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] GameOverPanel reference is NULL!&quot;);&#10;        }&#10;&#10;        // Ensure main panel is visible for normal startup&#10;        if (mainPanel)&#10;        {&#10;            mainPanel.SetActive(true);&#10;            Debug.Log($&quot;[MainMenu] MainPanel activated - Active: {mainPanel.activeSelf}&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] MainPanel reference is NULL!&quot;);&#10;        }&#10;&#10;        Debug.Log(&quot;[MainMenu] Initial panel state set - only MainPanel should be visible&quot;);&#10;&#10;        // CRITICAL: Ensure EventSystem exists for button clicks&#10;        var eventSystem = UnityEngine.EventSystems.EventSystem.current;&#10;        if (eventSystem == null)&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] No EventSystem found! Creating one...&quot;);&#10;            var eventSystemObj = new GameObject(&quot;EventSystem&quot;);&#10;            eventSystemObj.AddComponent&lt;UnityEngine.EventSystems.EventSystem&gt;();&#10;            eventSystemObj.AddComponent&lt;UnityEngine.EventSystems.StandaloneInputModule&gt;();&#10;            Debug.Log(&quot;[MainMenu] EventSystem created&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.Log($&quot;[MainMenu] EventSystem found: {eventSystem.gameObject.name}&quot;);&#10;        }&#10;&#10;        // CRITICAL: Ensure FadeScreen isn't blocking input AND is transparent for main menu&#10;        var fadeScreen = GameObject.Find(&quot;FadeScreen&quot;)?.GetComponent&lt;UnityEngine.UI.Image&gt;();&#10;        if (fadeScreen != null)&#10;        {&#10;            if (fadeScreen.raycastTarget)&#10;            {&#10;                fadeScreen.raycastTarget = false;&#10;                Debug.Log(&quot;[MainMenu] FadeScreen raycasts disabled to unblock main menu input&quot;);&#10;            }&#10;&#10;            if (fadeScreen.color.a &gt; 0f)&#10;            {&#10;                fadeScreen.color = new Color(0, 0, 0, 0);&#10;                Debug.Log(&quot;[MainMenu] FadeScreen color reset to transparent for main menu&quot;);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] FadeScreen not found!&quot;);&#10;        }&#10;&#10;        // Find player reference&#10;        player = GameObject.FindGameObjectWithTag(playerTag);&#10;&#10;        // Auto-find gameplay canvas if not assigned&#10;        if (!gameplayCanvas)&#10;        {&#10;            // Try to find a canvas named &quot;Canvas&quot; or &quot;GameplayCanvas&quot; or &quot;HUD&quot;&#10;            gameplayCanvas = GameObject.Find(&quot;Canvas&quot;) ?? GameObject.Find(&quot;GameplayCanvas&quot;) ?? GameObject.Find(&quot;HUD&quot;);&#10;        }&#10;&#10;        // Cache text elements by tags&#10;        CacheTextElements();&#10;&#10;        // Setup button listeners&#10;        SetupButtonListeners();&#10;&#10;        // Ensure canvas is properly configured for input&#10;        EnsureCanvasConfiguration();&#10;        ConfigureDecorativeOverlays();&#10;&#10;        // Check if we're auto-starting from a retry&#10;        bool autoStart = PlayerPrefs.GetInt(&quot;RetryAutoStart&quot;, 0) == 1;&#10;        &#10;        if (autoStart)&#10;        {&#10;            Debug.Log(&quot;[MainMenu] Auto-starting from retry&quot;);&#10;            &#10;            // Restore DDA settings&#10;            bool wasDDAEnabled = PlayerPrefs.GetInt(&quot;RetryDDAEnabled&quot;, 1) == 1;&#10;            int previousDifficulty = PlayerPrefs.GetInt(&quot;RetryDifficulty&quot;, 0);&#10;            &#10;            if (wasDDAEnabled)&#10;            {&#10;                // Restore DDA mode&#10;                DifficultyTracker.EnableTestingMode(false);&#10;                Debug.Log(&quot;[MainMenu] Restored DDA mode from retry&quot;);&#10;            }&#10;            else&#10;            {&#10;                // Restore static difficulty mode&#10;                DifficultyTracker.EnableTestingMode(true);&#10;                DifficultyTracker.SetTestingDifficultyPercent(previousDifficulty);&#10;                Debug.Log($&quot;[MainMenu] Restored static difficulty {previousDifficulty}% from retry&quot;);&#10;            }&#10;            &#10;            // Clear the retry flag&#10;            PlayerPrefs.DeleteKey(&quot;RetryAutoStart&quot;);&#10;            PlayerPrefs.DeleteKey(&quot;RetryDDAEnabled&quot;);&#10;            PlayerPrefs.DeleteKey(&quot;RetryDifficulty&quot;);&#10;            PlayerPrefs.Save();&#10;&#10;            // Start game immediately without showing menu&#10;            // StartGameplayScene();&#10;            // Fade to gameplay scene + audio fade&#10;            OnFadeToGameplayScene();&#10;            StartCoroutine(FadeOutMusic(menuMusicSource, 1f, false)); // 1f matches default fade out duration&#10;        }&#10;        else&#10;        {&#10;            // Normal start - setup initial state&#10;            if (showOnStart)&#10;            {&#10;                ShowMenu();&#10;            }&#10;            else&#10;            {&#10;                HideMenu();&#10;            }&#10;        }&#10;&#10;        // Initialize DDA toggle state (only if not auto-starting)&#10;        if (!autoStart &amp;&amp; ddaToggle)&#10;        {&#10;            ddaToggle.isOn = true; // Default to DDA enabled&#10;            OnDDAToggleChanged(ddaToggle.isOn);&#10;        }&#10;    }&#10;&#10;    private void Update()&#10;    {&#10;        // Don't allow ESC key to trigger pause menu if any main menu panels are showing&#10;        if ((mainPanel != null &amp;&amp; mainPanel.activeSelf) ||&#10;            (creditsPanel != null &amp;&amp; creditsPanel.activeSelf) ||&#10;            (difficultyPanel != null &amp;&amp; difficultyPanel.activeSelf))&#10;        {&#10;            return; // Ignore ESC key when on main menu screens&#10;        }&#10;&#10;        // Allow ESC key to show pause menu during gameplay (not game over, not already paused)&#10;        if (Input.GetKeyDown(KeyCode.Escape) &amp;&amp; !isGamePaused &amp;&amp; !isGameOver)&#10;        {&#10;            Debug.Log(&quot;[MainMenu] ESC pressed - showing pause menu&quot;);&#10;            ShowPauseMenu();&#10;        }&#10;        else if (Input.GetKeyDown(KeyCode.Escape) &amp;&amp; isGameOver)&#10;        {&#10;            Debug.Log(&quot;[MainMenu] ESC pressed but game is over - ignoring&quot;);&#10;        }&#10;        else if (Input.GetKeyDown(KeyCode.Escape) &amp;&amp; isGamePaused)&#10;        {&#10;            Debug.Log(&quot;[MainMenu] ESC pressed while paused - resuming game&quot;);&#10;            OnResumeClicked();&#10;        }&#10;    }&#10;&#10;    public void ShowMenu()&#10;    {&#10;        ShowMenu(shouldUnloadGameplay: false);&#10;    }&#10;&#10;    public void ShowMenu(bool shouldUnloadGameplay)&#10;    {&#10;        isGamePaused = true;&#10;&#10;        SetGameplayInputActive(false);&#10;        // Show the main menu&#10;        if (mainPanel) mainPanel.SetActive(true);&#10;        if (creditsPanel) creditsPanel.SetActive(false);&#10;        if (difficultyPanel) difficultyPanel.SetActive(false);&#10;        if (pausePanel) pausePanel.SetActive(false);&#10;        if (gameOverPanel) gameOverPanel.SetActive(false);&#10;&#10;        // Show MainPanel text elements&#10;        ShowMainPanelText();&#10;&#10;        // Hide gameplay UI elements&#10;        HideGameplayUI();&#10;&#10;        // Pause the game&#10;        // Time.timeScale = 0f;&#10;&#10;        // Mute gameplay audio and play menu music&#10;        MuteGameplayAudio();&#10;        PlayMenuMusic();&#10;&#10;        // Disable player controls&#10;        if (player)&#10;        {&#10;            DisablePlayerControls();&#10;        }&#10;&#10;        // Unlock and show cursor&#10;        Cursor.lockState = CursorLockMode.None;&#10;        Cursor.visible = true;&#10;&#10;        // Only unload gameplay scene if explicitly requested (e.g., after winning the game)&#10;        if (shouldUnloadGameplay &amp;&amp; IsGameplaySceneLoaded)&#10;        {&#10;            Debug.Log(&quot;[MainMenu] Unloading gameplay scene to ensure clean state for next game&quot;);&#10;            UnloadGameplayScene();&#10;        }&#10;    }&#10;&#10;    public void ShowPauseMenu()&#10;    {&#10;        isGamePaused = true;&#10;        &#10;        SetGameplayInputActive(false);&#10;        &#10;        // Ensure EventSystem is active and ready&#10;        EnsureEventSystemActive();&#10;        &#10;        // Show the pause menu&#10;        if (mainPanel) mainPanel.SetActive(false);&#10;        if (creditsPanel) creditsPanel.SetActive(false);&#10;        if (difficultyPanel) difficultyPanel.SetActive(false);&#10;        if (pausePanel) &#10;        {&#10;            pausePanel.SetActive(true);&#10;            Debug.Log($&quot;[MainMenu] PausePanel.SetActive(true) called - ActiveSelf={pausePanel.activeSelf}, ActiveInHierarchy={pausePanel.activeInHierarchy}&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.LogError(&quot;[MainMenu] PausePanel reference is NULL!&quot;);&#10;        }&#10;        if (gameOverPanel) gameOverPanel.SetActive(false);&#10;&#10;        // Hide gameplay UI elements&#10;        HideGameplayUI();&#10;&#10;        // Pause the game&#10;        Time.timeScale = 0f;&#10;&#10;        // Disable player controls&#10;        if (player)&#10;        {&#10;            DisablePlayerControls();&#10;        }&#10;&#10;        // Unlock and show cursor&#10;        Cursor.lockState = CursorLockMode.None;&#10;        Cursor.visible = true;&#10;        &#10;        // Mute gameplay audio and play pause music with fade-in&#10;        MuteGameplayAudio();&#10;        ToggleGameMusicWithFade(false);&#10;        PlayPauseMusicWithFadeIn();&#10;        &#10;        // Force enable button GameObjects if they're disabled&#10;        ForceEnableButtons();&#10;        &#10;        // Debug button states AFTER showing panels&#10;        DebugButtonStates();&#10;        &#10;        // Check for Graphic Raycaster&#10;        CheckGraphicRaycaster();&#10;        &#10;        Debug.Log(&quot;[MainMenu] Game Paused - Pause Panel Active&quot;);&#10;    }&#10;&#10;    public void ShowGameOverMenu()&#10;    {&#10;        Debug.Log(&quot;[MainMenu] ========== SHOWING GAME OVER MENU ==========&quot;);&#10;        isGamePaused = true;&#10;        isGameOver = true;&#10;        &#10;        SetGameplayInputActive(false);&#10;        &#10;        // Ensure EventSystem is active and ready&#10;        EnsureEventSystemActive();&#10;        &#10;        // Show the game over menu&#10;        if (mainPanel) mainPanel.SetActive(false);&#10;        if (creditsPanel) creditsPanel.SetActive(false);&#10;        if (difficultyPanel) difficultyPanel.SetActive(false);&#10;        if (pausePanel) pausePanel.SetActive(false);&#10;        if (gameOverPanel) gameOverPanel.SetActive(true);&#10;&#10;        // Hide gameplay UI elements&#10;        HideGameplayUI();&#10;&#10;        // Pause the game&#10;        Time.timeScale = 0f;&#10;&#10;        // Disable player controls&#10;        if (player)&#10;        {&#10;            DisablePlayerControls();&#10;        }&#10;&#10;        // Unlock and show cursor&#10;        Cursor.lockState = CursorLockMode.None;&#10;        Cursor.visible = true;&#10;        &#10;        // Mute gameplay audio with fade and play game over music with fade-in&#10;        StartCoroutine(MuteGameplayAudioDelayed(muteAudioDelay));&#10;        PlayGameOverMusicWithFadeIn();&#10;        &#10;        // Force enable button GameObjects if they're disabled&#10;        ForceEnableButtons();&#10;        &#10;        // Debug button states&#10;        DebugButtonStates();&#10;        &#10;        // Check for Graphic Raycaster&#10;        CheckGraphicRaycaster();&#10;        &#10;        Debug.Log(&quot;[MainMenu] Game Over - Game Over Panel Active&quot;);&#10;    }&#10;&#10;    public void HideMenu()&#10;    {&#10;        Debug.Log(&quot;[MainMenu] ========== HIDING ALL MENUS ==========&quot;);&#10;        Debug.Log($&quot;[MainMenu] Previous state - isGamePaused: {isGamePaused}, isGameOver: {isGameOver}&quot;);&#10;        &#10;        isGamePaused = false;&#10;        isGameOver = false;&#10;&#10;        // Hide ALL panels&#10;        if (mainPanel) mainPanel.SetActive(false);&#10;        if (creditsPanel) creditsPanel.SetActive(false);&#10;        if (difficultyPanel) difficultyPanel.SetActive(false);&#10;        if (pausePanel) &#10;        {&#10;            pausePanel.SetActive(false);&#10;            Debug.Log(&quot;[MainMenu] Deactivated Pause panel&quot;);&#10;        }&#10;        if (gameOverPanel) &#10;        {&#10;            gameOverPanel.SetActive(false);&#10;            Debug.Log(&quot;[MainMenu] Deactivated GameOver panel&quot;);&#10;        }&#10;&#10;        // Hide all text elements&#10;        HideAllPanelText();&#10;&#10;        // Re-enable gameplay EventSystems&#10;        RestoreGameplayEventSystems();&#10;&#10;        // Show gameplay UI elements&#10;        ShowGameplayUI();&#10;&#10;        // Unpause the game&#10;        Time.timeScale = 1f;&#10;&#10;        // Enable player controls&#10;        if (player)&#10;        {&#10;            EnablePlayerControls();&#10;        }&#10;&#10;        // Lock and hide cursor for gameplay&#10;        Cursor.lockState = CursorLockMode.Locked;&#10;        Cursor.visible = false;&#10;        &#10;        // Stop all menu music with fade out and unmute gameplay audio (unless retrying, which has its own delay)&#10;        StopMenuMusic();&#10;        StopPauseMusicWithFadeOut();&#10;        StopGameOverMusicWithFadeOut();&#10;        if (!isRetrying &amp;&amp; gameStarted)&#10;        {&#10;            UnmuteGameplayAudio();&#10;        }&#10;        &#10;        SetGameplayInputActive(true);&#10;    }&#10;&#10;    private void HideGameplayUI()&#10;    {&#10;        if (gameplayCanvas) gameplayCanvas.SetActive(false);&#10;    }&#10;&#10;    private void ShowGameplayUI()&#10;    {&#10;        if (gameplayCanvas) gameplayCanvas.SetActive(true);&#10;    }&#10;&#10;    private void OnPlayClicked()&#10;    {&#10;        // Check if DDA is enabled&#10;        bool isDDAEnabled = ddaToggle &amp;&amp; ddaToggle.isOn;&#10;&#10;        if (isDDAEnabled)&#10;        {&#10;            // DDA is enabled - start game immediately with dynamic difficulty&#10;            DifficultyTracker.EnableTestingMode(false);&#10;            Debug.Log(&quot;Dynamic Difficulty Adjustment: ENABLED - Starting game&quot;);&#10;            //StartGameplayScene();&#10;            // Fade to gameplay scene + audio fade&#10;            OnFadeToGameplayScene();&#10;            StartCoroutine(FadeOutMusic(menuMusicSource, 1f, false)); // 1f matches default fade out duration&#10;        }&#10;        else&#10;        {&#10;            // DDA is disabled - show difficulty selection panel&#10;            Debug.Log(&quot;Static Difficulty Mode - Select difficulty&quot;);&#10;            if (mainPanel) mainPanel.SetActive(false);&#10;            if (difficultyPanel) difficultyPanel.SetActive(true);&#10;            &#10;            // Show difficulty panel text elements&#10;            ShowDifficultyPanelText();&#10;        }&#10;    }&#10;&#10;    private void OnDifficultySelected(int difficultyPercent)&#10;    {&#10;        // Set static difficulty&#10;        DifficultyTracker.EnableTestingMode(true);&#10;        DifficultyTracker.SetTestingDifficultyPercent(difficultyPercent);&#10;        &#10;        string difficultyName = difficultyPercent switch&#10;        {&#10;            0 =&gt; &quot;Easy&quot;,&#10;            50 =&gt; &quot;Medium&quot;,&#10;            100 =&gt; &quot;Hard&quot;,&#10;            _ =&gt; &quot;Unknown&quot;&#10;        };&#10;        &#10;        Debug.Log($&quot;Static Difficulty Set: {difficultyName} ({difficultyPercent}%) - Starting game&quot;);&#10;&#10;        // Start the game&#10;        //StartGameplayScene();&#10;        // Fade to gameplay scene + audio fade&#10;        OnFadeToGameplayScene();&#10;        StartCoroutine(FadeOutMusic(menuMusicSource, 1f, false)); // 1f matches default fade out duration&#10;    }&#10;&#10;    private void OnCreditsClicked()&#10;    {&#10;        if (mainPanel) mainPanel.SetActive(false);&#10;        if (creditsPanel) creditsPanel.SetActive(true);&#10;        ShowCreditsPanelText();&#10;    }&#10;&#10;    public void OnBackFromCredits()&#10;    {&#10;        if (mainPanel) mainPanel.SetActive(true);&#10;        if (creditsPanel) creditsPanel.SetActive(false);&#10;        ShowMainPanelText();&#10;    }&#10;&#10;    public void OnBackFromDifficulty()&#10;    {&#10;        if (difficultyPanel) difficultyPanel.SetActive(false);&#10;        if (mainPanel) mainPanel.SetActive(true);&#10;        ShowMainPanelText();&#10;    }&#10;&#10;    private void OnExitClicked()&#10;    {&#10;        #if UNITY_EDITOR&#10;            UnityEditor.EditorApplication.isPlaying = false;&#10;        #else&#10;            Application.Quit();&#10;        #endif&#10;    }&#10;&#10;    private void OnDDAToggleChanged(bool isEnabled)&#10;    {&#10;        // Just log the change - actual behavior happens on Play button&#10;        if (isEnabled)&#10;        {&#10;            Debug.Log(&quot;Dynamic Difficulty Mode Selected&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.Log(&quot;Static Difficulty Mode Selected&quot;);&#10;        }&#10;    }&#10;&#10;    private void DisablePlayerControls()&#10;    {&#10;        if (!player) return;&#10;&#10;        // Disable player input components&#10;        var playerActions = player.GetComponent&lt;PlayerActions&gt;();&#10;        if (playerActions) playerActions.enabled = false;&#10;&#10;        var playerMovement = player.GetComponent&lt;MonoBehaviour&gt;();&#10;        if (playerMovement &amp;&amp; playerMovement.GetType().Name.Contains(&quot;Movement&quot;))&#10;        {&#10;            playerMovement.enabled = false;&#10;        }&#10;&#10;        // Disable any other player control scripts as needed&#10;        var allPlayerScripts = player.GetComponents&lt;MonoBehaviour&gt;();&#10;        foreach (var script in allPlayerScripts)&#10;        {&#10;            string scriptName = script.GetType().Name;&#10;            if (scriptName.Contains(&quot;Player&quot;) &amp;&amp; &#10;                (scriptName.Contains(&quot;Movement&quot;) || scriptName.Contains(&quot;Interact&quot;) || scriptName.Contains(&quot;Action&quot;)))&#10;            {&#10;                script.enabled = false;&#10;            }&#10;        }&#10;    }&#10;&#10;    private void EnablePlayerControls()&#10;    {&#10;        if (!player) return;&#10;&#10;        // Re-enable player input components&#10;        var playerActions = player.GetComponent&lt;PlayerActions&gt;();&#10;        if (playerActions) playerActions.enabled = true;&#10;&#10;        // Re-enable movement and interaction&#10;        var allPlayerScripts = player.GetComponents&lt;MonoBehaviour&gt;();&#10;        foreach (var script in allPlayerScripts)&#10;        {&#10;            string scriptName = script.GetType().Name;&#10;            if (scriptName.Contains(&quot;Player&quot;) &amp;&amp; &#10;                (scriptName.Contains(&quot;Movement&quot;) || scriptName.Contains(&quot;Interact&quot;) || scriptName.Contains(&quot;Action&quot;)))&#10;            {&#10;                script.enabled = true;&#10;            }&#10;        }&#10;        &#10;        // Restore PlayerInteract state - trigger the canInteract event to ensure proper state&#10;        var playerInteract = player.GetComponent&lt;PlayerInteract&gt;();&#10;        if (playerInteract)&#10;        {&#10;            // Re-trigger the interact permission based on current objective state&#10;            // This ensures the component gets the correct canInteract state after being re-enabled&#10;            if(ObjectivesManager.Instance != null &amp;&amp; ObjectivesManager.Instance.completedTutorial)&#10;            {&#10;                PlayerActions.OnCanInteract(true);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void RefreshObjectiveDisplay()&#10;    {&#10;        // Trigger the objectives manager to re-display the current objective&#10;        if (ObjectivesManager.Instance != null &amp;&amp; ObjectivesManager.Instance.CurrentObjective != null)&#10;        {&#10;            ObjectivesManager.OnDisplayObjective(ObjectivesManager.Instance.CurrentObjective, 0, 0f);&#10;        }&#10;    }&#10;&#10;    public void StartGameplayScene()&#10;    {&#10;        if (IsGameplaySceneLoaded)&#10;        {&#10;            Debug.Log(&quot;[MainMenu] Gameplay scene already loaded - unloading it first to start fresh&quot;);&#10;            UnloadGameplayScene();&#10;            // After unloading completes, we'll load it fresh&#10;            StartCoroutine(WaitForUnloadThenLoadGameplay());&#10;            return;&#10;        }&#10;&#10;        isTransitioningToGameplay = true;&#10;        HideMenu();&#10;        Debug.Log($&quot;[MainMenu] Loading gameplay scene '{gameplaySceneName}' (additive)&quot;);&#10;        SceneManager.LoadSceneAsync(gameplaySceneName, LoadSceneMode.Additive);&#10;    }&#10;&#10;    private System.Collections.IEnumerator WaitForUnloadThenLoadGameplay()&#10;    {&#10;        // Wait for unload to complete&#10;        while (IsGameplaySceneLoaded)&#10;        {&#10;            yield return null;&#10;        }&#10;&#10;        Debug.Log(&quot;[MainMenu] Old gameplay scene unloaded, loading fresh gameplay scene&quot;);&#10;        isTransitioningToGameplay = true;&#10;        HideMenu();&#10;        SceneManager.LoadSceneAsync(gameplaySceneName, LoadSceneMode.Additive);&#10;    }&#10;&#10;    private void LoadMainMenuScene()&#10;    {&#10;        isTransitioningToGameplay = false;&#10;        Debug.Log($&quot;[MainMenu] Returning to main menu scene '{mainMenuSceneName}'&quot;);&#10;        var menuScene = SceneManager.GetSceneByName(mainMenuSceneName);&#10;        if (menuScene.isLoaded)&#10;        {&#10;            SceneManager.SetActiveScene(menuScene);&#10;            ShowMenu();&#10;            UnloadGameplayScene();&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning($&quot;[MainMenu] Main menu scene '{mainMenuSceneName}' is not loaded yet.&quot;);&#10;        }&#10;    }&#10;&#10;    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)&#10;    {&#10;        if (scene.name == gameplaySceneName)&#10;        {&#10;            CacheGameplayReferences(scene);&#10;            SceneManager.SetActiveScene(scene);&#10;            if (isTransitioningToGameplay)&#10;            {&#10;                HideMenu();&#10;                isTransitioningToGameplay = false;&#10;                &#10;                // Unload the MainMenu scene after gameplay scene is loaded&#10;                // DontDestroyOnLoad objects (like the menu canvas) will persist&#10;                UnloadMainMenuScene();&#10;            }&#10;        }&#10;        else if (scene.name == mainMenuSceneName)&#10;        {&#10;            SceneManager.SetActiveScene(scene);&#10;            ShowMenu();&#10;        }&#10;    }&#10;&#10;    private void CacheGameplayReferences(Scene scene)&#10;    {&#10;        player = GameObject.FindGameObjectWithTag(playerTag);&#10;        playerInput = player?.GetComponent&lt;PlayerInput&gt;();&#10;        if (gameplayCanvas == null || gameplayCanvas.scene != scene)&#10;        {&#10;            gameplayCanvas = FindGameplayCanvas(scene);&#10;        }&#10;    }&#10;&#10;    private GameObject FindGameplayCanvas(Scene scene)&#10;    {&#10;        string[] candidateNames = { &quot;GameplayCanvas&quot;, &quot;HUD&quot;, &quot;Canvas&quot; };&#10;        foreach (var candidateName in candidateNames)&#10;        {&#10;            var candidate = GameObject.Find(candidateName);&#10;            if (candidate &amp;&amp; candidate.scene == scene)&#10;            {&#10;                return candidate;&#10;            }&#10;        }&#10;&#10;        foreach (var root in scene.GetRootGameObjects())&#10;        {&#10;            var canvas = root.GetComponentInChildren&lt;Canvas&gt;(true);&#10;            if (canvas)&#10;            {&#10;                return canvas.gameObject;&#10;            }&#10;        }&#10;&#10;        return null;&#10;    }&#10;&#10;    private void OnDestroy()&#10;    {&#10;        SceneManager.sceneLoaded -= OnSceneLoaded;&#10;        &#10;        // Unsubscribe from checkpoint events&#10;        CheckpointManager.loadCheckpoint -= OnCheckpointLoaded;&#10;        &#10;        // Clean up listeners&#10;        if (playButton) playButton.onClick.RemoveListener(OnPlayClicked);&#10;        if (creditsButton) creditsButton.onClick.RemoveListener(OnCreditsClicked);&#10;        if (exitButton) exitButton.onClick.RemoveListener(OnExitClicked);&#10;        if (creditsBackButton) creditsBackButton.onClick.RemoveListener(OnBackFromCredits);&#10;        if (difficultyBackButton) difficultyBackButton.onClick.RemoveListener(OnBackFromDifficulty);&#10;        if (ddaToggle) ddaToggle.onValueChanged.RemoveListener(OnDDAToggleChanged);&#10;        if (easyButton) easyButton.onClick.RemoveListener(() =&gt; OnDifficultySelected(0));&#10;        if (mediumButton) mediumButton.onClick.RemoveListener(() =&gt; OnDifficultySelected(50));&#10;        if (hardButton) hardButton.onClick.RemoveListener(() =&gt; OnDifficultySelected(100));&#10;        &#10;        // Pause panel&#10;        if (resumeButton) resumeButton.onClick.RemoveListener(OnResumeClicked);&#10;        if (pauseExitButton) pauseExitButton.onClick.RemoveListener(OnExitClicked);&#10;        &#10;        // Game over panel&#10;        if (retryButton) retryButton.onClick.RemoveListener(OnRetryClicked);&#10;        if (gameOverExitButton) gameOverExitButton.onClick.RemoveListener(OnExitClicked);&#10;        &#10;        // Clear singleton instance&#10;        if (Instance == this)&#10;        {&#10;            Instance = null;&#10;        }&#10;    }&#10;&#10;    private void OnResumeClicked()&#10;    {&#10;        Debug.Log(&quot;[MainMenu] Resuming game&quot;);&#10;        HideMenu();&#10;    }&#10;&#10;    private void OnRetryClicked()&#10;    {&#10;        Debug.Log(&quot;[MainMenu] Retrying level - Using checkpoint system&quot;);&#10;        isRetrying = true;&#10;        isGameOver = false;&#10;        HideMenu();&#10;        &#10;        // Start delayed audio unmute (gameplay audio stays muted for 2 seconds)&#10;        StartCoroutine(UnmuteGameplayAudioDelayed(retryAudioDelay));&#10;        &#10;        CheckpointManager.Instance?.BeginLoading();&#10;    }&#10;&#10;    private void OnCheckpointLoaded()&#10;    {&#10;        if (!isRetrying) return;&#10;&#10;        isRetrying = false;&#10;        Debug.Log(&quot;[MainMenu] Checkpoint loaded, retry complete&quot;);&#10;        GameOverManager.Instance?.ResetGameOver();&#10;    }&#10;&#10;    private void UnloadGameplayScene()&#10;    {&#10;        var gameplayScene = SceneManager.GetSceneByName(gameplaySceneName);&#10;        if (gameplayScene.isLoaded)&#10;        {&#10;            SceneManager.UnloadSceneAsync(gameplayScene);&#10;        }&#10;    }&#10;&#10;    private void UnloadMainMenuScene()&#10;    {&#10;        var mainMenuScene = SceneManager.GetSceneByName(mainMenuSceneName);&#10;        if (mainMenuScene.isLoaded)&#10;        {&#10;            Debug.Log($&quot;[MainMenu] Unloading MainMenu scene - DontDestroyOnLoad objects will persist&quot;);&#10;            SceneManager.UnloadSceneAsync(mainMenuScene);&#10;        }&#10;    }&#10;&#10;    private void EnsureEventSystem()&#10;    {&#10;        if (menuEventSystem &amp;&amp; menuEventSystem.gameObject)&#10;        {&#10;            SetupInputModule();&#10;            return;&#10;        }&#10;&#10;        // Search for existing EventSystem in the entire hierarchy&#10;        menuEventSystem = FindFirstObjectByType&lt;EventSystem&gt;();&#10;        &#10;        if (menuEventSystem == null)&#10;        {&#10;            // Create EventSystem as child of the canvas root, not this script object&#10;            Transform canvasRoot = transform;&#10;            while (canvasRoot.parent != null)&#10;            {&#10;                canvasRoot = canvasRoot.parent;&#10;            }&#10;            &#10;            var eventSystemContainer = new GameObject(&quot;MainMenu EventSystem&quot;);&#10;            eventSystemContainer.transform.SetParent(canvasRoot);&#10;            menuEventSystem = eventSystemContainer.AddComponent&lt;EventSystem&gt;();&#10;            Debug.Log(&quot;[MainMenu] Created persistent EventSystem for menu interaction&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.Log($&quot;[MainMenu] Found existing EventSystem: {menuEventSystem.name}&quot;);&#10;        }&#10;&#10;        SetupInputModule();&#10;    }&#10;&#10;    private void EnsureEventSystemActive()&#10;    {&#10;        // CRITICAL: Get canvas root and ensure it's on top&#10;        Transform canvasRoot = transform;&#10;        while (canvasRoot.parent != null)&#10;        {&#10;            canvasRoot = canvasRoot.parent;&#10;        }&#10;        &#10;        var canvas = canvasRoot.GetComponent&lt;Canvas&gt;();&#10;        if (canvas)&#10;        {&#10;            // FORCE canvas to render on top of everything else&#10;            canvas.sortingOrder = 9999;&#10;            canvas.overrideSorting = true;&#10;            Debug.Log($&quot;[MainMenu] Set Canvas sortingOrder to 9999 to render on top&quot;);&#10;            &#10;            // Ensure canvas render mode allows interaction&#10;            if (canvas.renderMode == RenderMode.ScreenSpaceCamera &amp;&amp; canvas.worldCamera == null)&#10;            {&#10;                Debug.LogWarning(&quot;[MainMenu] Canvas is in Camera mode but has no camera assigned!&quot;);&#10;            }&#10;            &#10;            // Ensure Graphic Raycaster is enabled&#10;            var raycaster = canvas.GetComponent&lt;GraphicRaycaster&gt;();&#10;            if (raycaster)&#10;            {&#10;                if (!raycaster.enabled)&#10;                {&#10;                    raycaster.enabled = true;&#10;                    Debug.Log(&quot;[MainMenu] Enabled Graphic Raycaster on Canvas&quot;);&#10;                }&#10;            }&#10;            else&#10;            {&#10;                Debug.LogError(&quot;[MainMenu] GraphicRaycaster MISSING! Adding it...&quot;);&#10;                raycaster = canvas.gameObject.AddComponent&lt;GraphicRaycaster&gt;();&#10;                Debug.Log(&quot;[MainMenu] GraphicRaycaster added to Canvas!&quot;);&#10;            }&#10;        }&#10;        &#10;        // Find all EventSystems in the scene&#10;        EventSystem[] allEventSystems = FindObjectsByType&lt;EventSystem&gt;(FindObjectsSortMode.None);&#10;        &#10;        Debug.Log($&quot;[MainMenu] Found {allEventSystems.Length} EventSystem(s) in scene&quot;);&#10;        &#10;        // Disable all EventSystems except our menu one&#10;        foreach (var es in allEventSystems)&#10;        {&#10;            if (es == menuEventSystem)&#10;            {&#10;                // Ensure our menu EventSystem is enabled&#10;                if (!es.enabled)&#10;                {&#10;                    es.enabled = true;&#10;                    Debug.Log(&quot;[MainMenu] Enabled menu EventSystem&quot;);&#10;                }&#10;                if (!es.gameObject.activeInHierarchy)&#10;                {&#10;                    es.gameObject.SetActive(true);&#10;                    Debug.Log(&quot;[MainMenu] Activated menu EventSystem GameObject&quot;);&#10;                }&#10;            }&#10;            else&#10;            {&#10;                // Temporarily disable other EventSystems to avoid conflicts&#10;                if (es.enabled)&#10;                {&#10;                    es.enabled = false;&#10;                    Debug.Log($&quot;[MainMenu] Disabled gameplay EventSystem: {es.name}&quot;);&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Ensure our EventSystem exists&#10;        if (menuEventSystem == null)&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] Menu EventSystem is null! Recreating...&quot;);&#10;            EnsureEventSystem();&#10;        }&#10;        &#10;        // Make sure the current selected object is cleared to allow button interactions&#10;        if (menuEventSystem != null)&#10;        {&#10;            menuEventSystem.SetSelectedGameObject(null);&#10;        }&#10;        &#10;        // CRITICAL: Disable gameplay camera raycasting&#10;        DisableGameplayCameraRaycasting();&#10;        &#10;        // Ensure input module is properly configured&#10;        SetupInputModule();&#10;        &#10;        // Force enable UI input actions&#10;        if (menuInputModule != null &amp;&amp; uiInputActions != null)&#10;        {&#10;            var uiActionMap = uiInputActions.FindActionMap(&quot;UI&quot;);&#10;            if (uiActionMap != null &amp;&amp; !uiActionMap.enabled)&#10;            {&#10;                uiActionMap.Enable();&#10;                Debug.Log(&quot;[MainMenu] Re-enabled UI input actions&quot;);&#10;            }&#10;        }&#10;    }&#10;    &#10;    private void DisableGameplayCameraRaycasting()&#10;    {&#10;        // Find all cameras and disable their PhysicsRaycaster during menu&#10;        Camera[] allCameras = FindObjectsByType&lt;Camera&gt;(FindObjectsSortMode.None);&#10;        &#10;        foreach (var cam in allCameras)&#10;        {&#10;            // Skip UI/Menu cameras&#10;            if (cam.gameObject.name.Contains(&quot;UI&quot;) || cam.gameObject.name.Contains(&quot;Menu&quot;))&#10;                continue;&#10;            &#10;            // Disable PhysicsRaycaster on gameplay cameras&#10;            var physicsRaycaster = cam.GetComponent&lt;PhysicsRaycaster&gt;();&#10;            if (physicsRaycaster &amp;&amp; physicsRaycaster.enabled)&#10;            {&#10;                physicsRaycaster.enabled = false;&#10;                Debug.Log($&quot;[MainMenu] Disabled PhysicsRaycaster on camera: {cam.name}&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void RestoreGameplayEventSystems()&#10;    {&#10;        // Find all EventSystems and re-enable the gameplay ones&#10;        EventSystem[] allEventSystems = FindObjectsByType&lt;EventSystem&gt;(FindObjectsSortMode.None);&#10;        &#10;        foreach (var es in allEventSystems)&#10;        {&#10;            if (es != menuEventSystem)&#10;            {&#10;                es.enabled = true;&#10;                Debug.Log($&quot;[MainMenu] Re-enabled gameplay EventSystem: {es.name}&quot;);&#10;            }&#10;            else&#10;            {&#10;                // Keep menu EventSystem active but it won't interfere&#10;                Debug.Log(&quot;[MainMenu] Menu EventSystem remains active for future use&quot;);&#10;            }&#10;        }&#10;        &#10;        // Re-enable gameplay camera raycasting&#10;        Camera[] allCameras = FindObjectsByType&lt;Camera&gt;(FindObjectsSortMode.None);&#10;        foreach (var cam in allCameras)&#10;        {&#10;            if (cam.gameObject.name.Contains(&quot;UI&quot;) || cam.gameObject.name.Contains(&quot;Menu&quot;))&#10;                continue;&#10;            &#10;            var physicsRaycaster = cam.GetComponent&lt;UnityEngine.EventSystems.PhysicsRaycaster&gt;();&#10;            if (physicsRaycaster &amp;&amp; !physicsRaycaster.enabled)&#10;            {&#10;                physicsRaycaster.enabled = true;&#10;                Debug.Log($&quot;[MainMenu] Re-enabled PhysicsRaycaster on camera: {cam.name}&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void SetupInputModule()&#10;    {&#10;        if (menuEventSystem == null)&#10;            return;&#10;&#10;        menuInputModule = menuEventSystem.GetComponent&lt;InputSystemUIInputModule&gt;();&#10;        if (menuInputModule == null)&#10;        {&#10;            menuInputModule = menuEventSystem.gameObject.AddComponent&lt;InputSystemUIInputModule&gt;();&#10;        }&#10;&#10;        if (menuInputModule != null &amp;&amp; uiInputActions != null)&#10;        {&#10;            menuInputModule.actionsAsset = uiInputActions;&#10;            &#10;            // Enable the UI input actions so they can receive input&#10;            var uiActionMap = uiInputActions.FindActionMap(&quot;UI&quot;);&#10;            if (uiActionMap != null)&#10;            {&#10;                uiActionMap.Enable();&#10;                Debug.Log(&quot;[MainMenu] UI Input actions enabled for menu interaction&quot;);&#10;            }&#10;        }&#10;        else if (uiInputActions == null)&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] UI Input Actions asset is not assigned! Menu buttons will not be clickable.&quot;);&#10;        }&#10;    }&#10;&#10;    private void SetGameplayInputActive(bool isActive)&#10;    {&#10;        if (playerInput == null &amp;&amp; player)&#10;        {&#10;            playerInput = player.GetComponent&lt;PlayerInput&gt;();&#10;        }&#10;&#10;        if (isActive)&#10;        {&#10;            if (playerInput)&#10;            {&#10;                playerInput.enabled = true;&#10;                playerInput.actions?.Enable();&#10;            }&#10;        }&#10;        else&#10;        {&#10;            // Disable all PlayerInput components to prevent gameplay input during menus&#10;            var allPlayerInputs = FindObjectsByType&lt;PlayerInput&gt;(FindObjectsSortMode.None);&#10;            foreach (var pi in allPlayerInputs)&#10;            {&#10;                if (pi.enabled)&#10;                {&#10;                    pi.actions?.Disable();&#10;                    pi.enabled = false;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private void SetupButtonListeners()&#10;    {&#10;        Debug.Log(&quot;[MainMenu] Setting up button listeners...&quot;);&#10;        &#10;        // Main menu buttons&#10;        if (playButton) &#10;        {&#10;            playButton.onClick.RemoveAllListeners();&#10;            playButton.onClick.AddListener(OnPlayClicked);&#10;            Debug.Log(&quot;[MainMenu] Play button listener added&quot;);&#10;        }&#10;        else Debug.LogWarning(&quot;[MainMenu] Play button is NULL!&quot;);&#10;        &#10;        if (creditsButton)&#10;        {&#10;            creditsButton.onClick.RemoveAllListeners();&#10;            creditsButton.onClick.AddListener(OnCreditsClicked);&#10;        }&#10;        &#10;        if (exitButton)&#10;        {&#10;            exitButton.onClick.RemoveAllListeners();&#10;            exitButton.onClick.AddListener(OnExitClicked);&#10;        }&#10;        &#10;        if (creditsBackButton)&#10;        {&#10;            creditsBackButton.onClick.RemoveAllListeners();&#10;            creditsBackButton.onClick.AddListener(OnBackFromCredits);&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] Credits back button is NULL!&quot;);&#10;        }&#10;        &#10;        if (difficultyBackButton)&#10;        {&#10;            difficultyBackButton.onClick.RemoveAllListeners();&#10;            difficultyBackButton.onClick.AddListener(OnBackFromDifficulty);&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] Difficulty back button is NULL!&quot;);&#10;        }&#10;        &#10;        if (ddaToggle)&#10;        {&#10;            ddaToggle.onValueChanged.RemoveAllListeners();&#10;            ddaToggle.onValueChanged.AddListener(OnDDAToggleChanged);&#10;        }&#10;        &#10;        // Setup difficulty button listeners&#10;        if (easyButton)&#10;        {&#10;            easyButton.onClick.RemoveAllListeners();&#10;            easyButton.onClick.AddListener(() =&gt; OnDifficultySelected(0));&#10;        }&#10;        &#10;        if (mediumButton)&#10;        {&#10;            mediumButton.onClick.RemoveAllListeners();&#10;            mediumButton.onClick.AddListener(() =&gt; OnDifficultySelected(50));&#10;        }&#10;        &#10;        if (hardButton)&#10;        {&#10;            hardButton.onClick.RemoveAllListeners();&#10;            hardButton.onClick.AddListener(() =&gt; OnDifficultySelected(100));&#10;        }&#10;        &#10;        // Setup pause panel button listeners&#10;        if (resumeButton)&#10;        {&#10;            resumeButton.onClick.RemoveAllListeners();&#10;            resumeButton.onClick.AddListener(OnResumeClicked);&#10;            Debug.Log(&quot;[MainMenu] Resume button listener added&quot;);&#10;        }&#10;        else Debug.LogWarning(&quot;[MainMenu] Resume button is NULL!&quot;);&#10;        &#10;        if (pauseExitButton)&#10;        {&#10;            pauseExitButton.onClick.RemoveAllListeners();&#10;            pauseExitButton.onClick.AddListener(OnExitClicked);&#10;        }&#10;        &#10;        // Setup game over panel button listeners&#10;        if (retryButton)&#10;        {&#10;            retryButton.onClick.RemoveAllListeners();&#10;            retryButton.onClick.AddListener(OnRetryClicked);&#10;            Debug.Log(&quot;[MainMenu] Retry button listener added&quot;);&#10;        }&#10;        else Debug.LogWarning(&quot;[MainMenu] Retry button is NULL!&quot;);&#10;        &#10;        if (gameOverExitButton)&#10;        {&#10;            gameOverExitButton.onClick.RemoveAllListeners();&#10;            gameOverExitButton.onClick.AddListener(OnExitClicked);&#10;        }&#10;        &#10;        Debug.Log(&quot;[MainMenu] Button listeners setup complete!&quot;);&#10;    }&#10;&#10;    private void DebugButtonStates()&#10;    {&#10;        Debug.Log(&quot;[MainMenu] === BUTTON DEBUG INFO ===&quot;);&#10;        &#10;        // Check pause panel state&#10;        if (pausePanel)&#10;        {&#10;            Debug.Log($&quot;[MainMenu] Pause Panel: ActiveSelf={pausePanel.activeSelf}, ActiveInHierarchy={pausePanel.activeInHierarchy}&quot;);&#10;        }&#10;        &#10;        if (resumeButton)&#10;        {&#10;            string hierarchy = GetGameObjectPath(resumeButton.gameObject);&#10;            Debug.Log($&quot;[MainMenu] Resume Button: Path='{hierarchy}'&quot;);&#10;            Debug.Log($&quot;[MainMenu] Resume Button: ActiveSelf={resumeButton.gameObject.activeSelf}, &quot; +&#10;                     $&quot;ActiveInHierarchy={resumeButton.gameObject.activeInHierarchy}, &quot; +&#10;                     $&quot;Enabled={resumeButton.enabled}, Interactable={resumeButton.interactable}, &quot; +&#10;                     $&quot;Listeners={resumeButton.onClick.GetPersistentEventCount()}&quot;);&#10;            &#10;            // Check if button's GameObject itself is disabled&#10;            if (!resumeButton.gameObject.activeSelf)&#10;            {&#10;                Debug.LogError($&quot;[MainMenu] &gt;&gt;&gt; RESUME BUTTON GAMEOBJECT IS DISABLED! &lt;&lt;&lt;&quot;);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            Debug.LogError(&quot;[MainMenu] Resume Button reference is NULL!&quot;);&#10;        }&#10;        &#10;        // Check game over panel state&#10;        if (gameOverPanel)&#10;        {&#10;            Debug.Log($&quot;[MainMenu] GameOver Panel: ActiveSelf={gameOverPanel.activeSelf}, ActiveInHierarchy={gameOverPanel.activeInHierarchy}&quot;);&#10;        }&#10;        &#10;        if (retryButton)&#10;        {&#10;            string hierarchy = GetGameObjectPath(retryButton.gameObject);&#10;            Debug.Log($&quot;[MainMenu] Retry Button: Path='{hierarchy}'&quot;);&#10;            Debug.Log($&quot;[MainMenu] Retry Button: ActiveSelf={retryButton.gameObject.activeSelf}, &quot; +&#10;                     $&quot;ActiveInHierarchy={retryButton.gameObject.activeInHierarchy}, &quot; +&#10;                     $&quot;Enabled={retryButton.enabled}, Interactable={retryButton.interactable}, &quot; +&#10;                     $&quot;Listeners={retryButton.onClick.GetPersistentEventCount()}&quot;);&#10;            &#10;            // Check if button's GameObject itself is disabled&#10;            if (!retryButton.gameObject.activeSelf)&#10;            {&#10;                Debug.LogError($&quot;[MainMenu] &gt;&gt;&gt; RETRY BUTTON GAMEOBJECT IS DISABLED! &lt;&lt;&lt;&quot;);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            Debug.LogError(&quot;[MainMenu] Retry Button reference is NULL!&quot;);&#10;        }&#10;        &#10;        if (pauseExitButton)&#10;        {&#10;            Debug.Log($&quot;[MainMenu] Pause Exit Button: ActiveInHierarchy={pauseExitButton.gameObject.activeInHierarchy}, &quot; +&#10;                     $&quot;Enabled={pauseExitButton.enabled}, Interactable={pauseExitButton.interactable}&quot;);&#10;        }&#10;        &#10;        if (gameOverExitButton)&#10;        {&#10;            Debug.Log($&quot;[MainMenu] GameOver Exit Button: ActiveInHierarchy={gameOverExitButton.gameObject.activeInHierarchy}, &quot; +&#10;                     $&quot;Enabled={gameOverExitButton.enabled}, Interactable={gameOverExitButton.interactable}&quot;);&#10;        }&#10;    }&#10;    &#10;    private string GetGameObjectPath(GameObject obj)&#10;    {&#10;        string path = obj.name;&#10;        Transform current = obj.transform.parent;&#10;        while (current != null)&#10;        {&#10;            path = current.name + &quot;/&quot; + path;&#10;            current = current.parent;&#10;        }&#10;        return path;&#10;    }&#10;&#10;    private void ForceEnableButtons()&#10;    {&#10;        Debug.Log(&quot;[MainMenu] === FORCE ENABLING BUTTONS ===&quot;);&#10;        &#10;        // ONLY process the panel that is CURRENTLY ACTIVE - don't activate inactive ones!&#10;        &#10;        // If pause panel is active, fix its buttons and CanvasGroup&#10;        if (pausePanel &amp;&amp; pausePanel.activeSelf)&#10;        {&#10;            Debug.Log(&quot;[MainMenu] Processing Pause Panel buttons (panel is active)&quot;);&#10;            &#10;            // Check for CanvasGroup that might be blocking interaction&#10;            var canvasGroup = pausePanel.GetComponent&lt;CanvasGroup&gt;();&#10;            if (canvasGroup)&#10;            {&#10;                if (!canvasGroup.interactable)&#10;                {&#10;                    Debug.LogWarning($&quot;[MainMenu] Pause Panel has CanvasGroup with interactable=false! Enabling it...&quot;);&#10;                    canvasGroup.interactable = true;&#10;                }&#10;                if (canvasGroup.blocksRaycasts == false)&#10;                {&#10;                    Debug.LogWarning($&quot;[MainMenu] Pause Panel CanvasGroup blocksRaycasts=false! Enabling it...&quot;);&#10;                    canvasGroup.blocksRaycasts = true;&#10;                }&#10;            }&#10;            &#10;            // Force enable pause panel buttons ONLY&#10;            if (resumeButton &amp;&amp; !resumeButton.gameObject.activeSelf)&#10;            {&#10;                Debug.LogWarning($&quot;[MainMenu] Resume button GameObject was disabled! Enabling it now...&quot;);&#10;                resumeButton.gameObject.SetActive(true);&#10;            }&#10;            &#10;            if (pauseExitButton &amp;&amp; !pauseExitButton.gameObject.activeSelf)&#10;            {&#10;                Debug.LogWarning($&quot;[MainMenu] Pause Exit button GameObject was disabled! Enabling it now...&quot;);&#10;                pauseExitButton.gameObject.SetActive(true);&#10;            }&#10;            &#10;        }&#10;        else if (pausePanel)&#10;        {&#10;            Debug.Log(&quot;[MainMenu] Pause Panel exists but is INACTIVE - skipping button processing&quot;);&#10;        }&#10;        &#10;        // If game over panel is active, fix its buttons and CanvasGroup&#10;        if (gameOverPanel &amp;&amp; gameOverPanel.activeSelf)&#10;        {&#10;            Debug.Log(&quot;[MainMenu] Processing GameOver Panel buttons (panel is active)&quot;);&#10;            &#10;            // Check for CanvasGroup that might be blocking interaction&#10;            var canvasGroup = gameOverPanel.GetComponent&lt;CanvasGroup&gt;();&#10;            if (canvasGroup)&#10;            {&#10;                if (!canvasGroup.interactable)&#10;                {&#10;                    Debug.LogWarning($&quot;[MainMenu] GameOver Panel has CanvasGroup with interactable=false! Enabling it...&quot;);&#10;                    canvasGroup.interactable = true;&#10;                }&#10;                if (canvasGroup.blocksRaycasts == false)&#10;                {&#10;                    Debug.LogWarning($&quot;[MainMenu] GameOver Panel CanvasGroup blocksRaycasts=false! Enabling it...&quot;);&#10;                    canvasGroup.blocksRaycasts = true;&#10;                }&#10;            }&#10;            &#10;            // Force enable game over panel buttons ONLY&#10;            if (retryButton &amp;&amp; !retryButton.gameObject.activeSelf)&#10;            {&#10;                Debug.LogWarning($&quot;[MainMenu] Retry button GameObject was disabled! Enabling it now...&quot;);&#10;                retryButton.gameObject.SetActive(true);&#10;            }&#10;            &#10;            if (gameOverExitButton &amp;&amp; !gameOverExitButton.gameObject.activeSelf)&#10;            {&#10;                Debug.LogWarning($&quot;[MainMenu] GameOver Exit button GameObject was disabled! Enabling it now...&quot;);&#10;                gameOverExitButton.gameObject.SetActive(true);&#10;            }&#10;        }&#10;        else if (gameOverPanel)&#10;        {&#10;            Debug.Log(&quot;[MainMenu] GameOver Panel exists but is INACTIVE - skipping button processing&quot;);&#10;        }&#10;    }&#10;    &#10;&#10;&#10;    private void CheckGraphicRaycaster()&#10;    {&#10;        Debug.Log(&quot;[MainMenu] === CANVAS RAYCASTER CHECK ===&quot;);&#10;        &#10;        // Get the canvas root&#10;        Transform canvasRoot = transform;&#10;        while (canvasRoot.parent != null)&#10;        {&#10;            canvasRoot = canvasRoot.parent;&#10;        }&#10;        &#10;        var canvas = canvasRoot.GetComponent&lt;Canvas&gt;();&#10;        if (canvas)&#10;        {&#10;            Debug.Log($&quot;[MainMenu] Canvas found: {canvas.name}&quot;);&#10;            &#10;            var raycaster = canvas.GetComponent&lt;UnityEngine.UI.GraphicRaycaster&gt;();&#10;            if (raycaster)&#10;            {&#10;                Debug.Log($&quot;[MainMenu] GraphicRaycaster FOUND: Enabled={raycaster.enabled}, &quot; +&#10;                         $&quot;IgnoreReversedGraphics={raycaster.ignoreReversedGraphics}&quot;);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogError(&quot;[MainMenu] GraphicRaycaster MISSING! Adding it now...&quot;);&#10;                raycaster = canvas.gameObject.AddComponent&lt;UnityEngine.UI.GraphicRaycaster&gt;();&#10;                Debug.Log(&quot;[MainMenu] GraphicRaycaster added to Canvas!&quot;);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            Debug.LogError(&quot;[MainMenu] Canvas component not found!&quot;);&#10;        }&#10;        &#10;        // Check EventSystem&#10;        if (menuEventSystem)&#10;        {&#10;            Debug.Log($&quot;[MainMenu] EventSystem: Enabled={menuEventSystem.enabled}, &quot; +&#10;                     $&quot;CurrentSelected={menuEventSystem.currentSelectedGameObject}&quot;);&#10;            &#10;            if (menuInputModule)&#10;            {&#10;                Debug.Log($&quot;[MainMenu] InputModule: Enabled={menuInputModule.enabled}, &quot; +&#10;                         $&quot;ActionsAsset={(menuInputModule.actionsAsset != null ? &quot;Assigned&quot; : &quot;NULL&quot;)}&quot;);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogError(&quot;[MainMenu] InputModule is NULL!&quot;);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            Debug.LogError(&quot;[MainMenu] EventSystem is NULL!&quot;);&#10;        }&#10;    }&#10;&#10;    private void CacheTextElements()&#10;    {&#10;        // Find all GameObjects with MainPanelElement tag&#10;        try&#10;        {&#10;            mainPanelTextElements = GameObject.FindGameObjectsWithTag(&quot;MainPanelElement&quot;);&#10;            Debug.Log($&quot;[MainMenu] Found {mainPanelTextElements.Length} text elements with MainPanelElement tag&quot;);&#10;        }&#10;        catch (UnityException)&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] Tag 'MainPanelElement' not defined in Tags and Layers. Please add it in Project Settings &gt; Tags and Layers&quot;);&#10;            mainPanelTextElements = new GameObject[0];&#10;        }&#10;&#10;        // Find all GameObjects with DifficultyElement tag&#10;        try&#10;        {&#10;            difficultyPanelTextElements = GameObject.FindGameObjectsWithTag(&quot;DifficultyElement&quot;);&#10;            Debug.Log($&quot;[MainMenu] Found {difficultyPanelTextElements.Length} text elements with DifficultyElement tag&quot;);&#10;        }&#10;        catch (UnityException)&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] Tag 'DifficultyElement' not defined in Tags and Layers. Please add it in Project Settings &gt; Tags and Layers&quot;);&#10;            difficultyPanelTextElements = new GameObject[0];&#10;        }&#10;&#10;        // Find all GameObjects with CreditsPanelElement tag&#10;        try&#10;        {&#10;            creditsPanelTextElements = GameObject.FindGameObjectsWithTag(&quot;CreditsPanelElement&quot;);&#10;            Debug.Log($&quot;[MainMenu] Found {creditsPanelTextElements.Length} text elements with CreditsPanelElement tag&quot;);&#10;        }&#10;        catch (UnityException)&#10;        {&#10;            Debug.LogWarning(&quot;[MainMenu] Tag 'CreditsPanelElement' not defined in Tags and Layers. Please add it in Project Settings &gt; Tags and Layers&quot;);&#10;            creditsPanelTextElements = new GameObject[0];&#10;        }&#10;    }&#10;&#10;    private void ShowMainPanelText()&#10;    {&#10;        // Show MainPanel text elements&#10;        if (mainPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in mainPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(true);&#10;                }&#10;            }&#10;            Debug.Log($&quot;[MainMenu] Showed {mainPanelTextElements.Length} MainPanel text elements&quot;);&#10;        }&#10;&#10;        // Hide DifficultyPanel text elements&#10;        if (difficultyPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in difficultyPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(false);&#10;                }&#10;            }&#10;        }&#10;        &#10;        if (creditsPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in creditsPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(false);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private void ShowDifficultyPanelText()&#10;    {&#10;        // Hide MainPanel text elements&#10;        if (mainPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in mainPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(false);&#10;                }&#10;            }&#10;        }&#10;&#10;        // Show DifficultyPanel text elements&#10;        if (difficultyPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in difficultyPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(true);&#10;                }&#10;            }&#10;            Debug.Log($&quot;[MainMenu] Showed {difficultyPanelTextElements.Length} DifficultyPanel text elements&quot;);&#10;        }&#10;        &#10;        if (creditsPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in creditsPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(false);&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    private void ShowCreditsPanelText()&#10;    {&#10;        if (mainPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in mainPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(false);&#10;                }&#10;            }&#10;        }&#10;        &#10;        if (difficultyPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in difficultyPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(false);&#10;                }&#10;            }&#10;        }&#10;        &#10;        if (creditsPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in creditsPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(true);&#10;                }&#10;            }&#10;            Debug.Log($&quot;[MainMenu] Showed {creditsPanelTextElements.Length} CreditsPanel text elements&quot;);&#10;        }&#10;    }&#10;&#10;    private void HideAllPanelText()&#10;    {&#10;        // Hide all text elements when no panel is showing&#10;        if (mainPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in mainPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(false);&#10;                }&#10;            }&#10;        }&#10;&#10;        if (difficultyPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in difficultyPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(false);&#10;                }&#10;            }&#10;        }&#10;        &#10;        if (creditsPanelTextElements != null)&#10;        {&#10;            foreach (var textElement in creditsPanelTextElements)&#10;            {&#10;                if (textElement != null)&#10;                {&#10;                    textElement.SetActive(false);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private void EnsureCanvasConfiguration()&#10;    {&#10;        // Get the canvas root&#10;        Transform canvasRoot = transform;&#10;        while (canvasRoot.parent != null)&#10;        {&#10;            canvasRoot = canvasRoot.parent;&#10;        }&#10;&#10;        var canvas = canvasRoot.GetComponent&lt;Canvas&gt;();&#10;        if (canvas == null)&#10;        {&#10;            Debug.LogError(&quot;[MainMenu] Canvas component not found on root!&quot;);&#10;            return;&#10;        }&#10;&#10;        Debug.Log($&quot;[MainMenu] Ensuring Canvas configuration - RenderMode: {canvas.renderMode}&quot;);&#10;&#10;        // Ensure Canvas has GraphicRaycaster&#10;        var raycaster = canvas.GetComponent&lt;GraphicRaycaster&gt;();&#10;        if (raycaster == null)&#10;        {&#10;            raycaster = canvas.gameObject.AddComponent&lt;GraphicRaycaster&gt;();&#10;            Debug.Log(&quot;[MainMenu] Added GraphicRaycaster to Canvas&quot;);&#10;        }&#10;        raycaster.enabled = true;&#10;&#10;        // If using Screen Space - Camera, ensure camera is assigned&#10;        if (canvas.renderMode == RenderMode.ScreenSpaceCamera &amp;&amp; canvas.worldCamera == null)&#10;        {&#10;            canvas.worldCamera = Camera.main;&#10;            Debug.Log(&quot;[MainMenu] Assigned Main Camera to Canvas&quot;);&#10;        }&#10;&#10;        // Set canvas to render on top&#10;        canvas.sortingOrder = 1000;&#10;        Debug.Log($&quot;[MainMenu] Canvas configured - Raycaster enabled, SortingOrder: {canvas.sortingOrder}&quot;);&#10;    }&#10;&#10;    private void ConfigureDecorativeOverlays()&#10;    {&#10;        if (nonBlockingGraphics != null)&#10;        {&#10;            foreach (var graphic in nonBlockingGraphics)&#10;            {&#10;                if (!graphic)&#10;                {&#10;                    continue;&#10;                }&#10;                if (graphic.raycastTarget)&#10;                {&#10;                    graphic.raycastTarget = false;&#10;                    Debug.Log($&quot;[MainMenu] Disabled raycast target on decor graphic '{graphic.name}'&quot;);&#10;                }&#10;            }&#10;        }&#10;        &#10;        if (nonBlockingCanvasGroups != null)&#10;        {&#10;            foreach (var canvasGroup in nonBlockingCanvasGroups)&#10;            {&#10;                if (!canvasGroup)&#10;                {&#10;                    continue;&#10;                }&#10;                if (canvasGroup.blocksRaycasts)&#10;                {&#10;                    canvasGroup.blocksRaycasts = false;&#10;                    Debug.Log($&quot;[MainMenu] Disabled raycast blocking on decor CanvasGroup '{canvasGroup.name}'&quot;);&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    #region Audio Management&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Mutes all gameplay audio sources (lasers, footsteps, etc.)&#10;    /// &lt;/summary&gt;&#10;    private void MuteGameplayAudio()&#10;    {&#10;        if (gameplayAudioMuted) return;&#10;        &#10;        Debug.LogWarning(&quot;[MainMenu] Muting gameplay audio&quot;);&#10;        gameplayAudioMuted = true;&#10;        &#10;        // Find and mute all AudioSources in the gameplay scene&#10;        AudioSource[] allAudioSources = FindObjectsByType&lt;AudioSource&gt;(FindObjectsInactive.Include, FindObjectsSortMode.None);&#10;        foreach (AudioSource audioSource in allAudioSources)&#10;        {&#10;            // Skip the menu music source&#10;            if (audioSource == menuMusicSource) continue;&#10;            &#10;            // Mute gameplay audio sources&#10;            if (audioSource.gameObject.scene.name == gameplaySceneName || &#10;                audioSource.CompareTag(gameplayAudioTag))&#10;            {&#10;                audioSource.mute = true;&#10;            }&#10;        }&#10;        ToggleGameMusicWithFade(false);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Unmutes all gameplay audio sources and restores volumes to 1.0&#10;    /// &lt;/summary&gt;&#10;    private void UnmuteGameplayAudio()&#10;    {&#10;        if (!gameplayAudioMuted) return;&#10;        &#10;        Debug.LogWarning(&quot;[MainMenu] Unmuting gameplay audio&quot;);&#10;        gameplayAudioMuted = false;&#10;        &#10;        // Find and unmute all AudioSources in the gameplay scene&#10;        AudioSource[] allAudioSources = FindObjectsByType&lt;AudioSource&gt;(FindObjectsInactive.Include, FindObjectsSortMode.None);&#10;        foreach (AudioSource audioSource in allAudioSources)&#10;        {&#10;            // Skip the menu music source&#10;            if (audioSource == menuMusicSource) continue;&#10;            &#10;            // Unmute gameplay audio sources and restore volume&#10;            if (audioSource.gameObject.scene.name == gameplaySceneName || &#10;                audioSource.CompareTag(gameplayAudioTag))&#10;            {&#10;                audioSource.mute = false;&#10;                // Restore volume to full (in case it was faded out)&#10;                if (audioSource.volume &lt; 0.1f)&#10;                {&#10;                    audioSource.volume = 1f;&#10;                }&#10;            }&#10;        }&#10;        ToggleGameMusicWithFade(true);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Toggles the gameplay music on or off with a fade effect.&#10;    /// &lt;/summary&gt;&#10;    void ToggleGameMusicWithFade(bool state)&#10;    {&#10;        if (gameplayMusicSource == null) &#10;        { &#10;            Debug.LogWarning(&quot;[MainMenu] Gameplay music source is NULL, cannot toggle music&quot;);&#10;            return;&#10;        }&#10;&#10;        if (gameplayAudioFadeCoroutine != null)&#10;        {&#10;            StopCoroutine(gameplayAudioFadeCoroutine);&#10;            gameplayAudioFadeCoroutine = null;&#10;        }&#10;        &#10;        Debug.LogWarning(&quot;[MainMenu] Toggling gameplay music with fade-in&quot;);&#10;        if (state)&#10;        {&#10;            gameplayAudioFadeCoroutine = StartCoroutine(FadeInMusic(gameplayMusicSource, musicFadeInDuration, isGameOverMusic: false));&#10;        }&#10;        else&#10;        {&#10;            gameplayAudioFadeCoroutine = StartCoroutine(FadeOutMusic(gameplayMusicSource, musicFadeOutDuration, isGameOverMusic: false, false));&#10;        }&#10;    }&#10;&#10;    void BeginGameMusic()&#10;    {&#10;        gameStarted = true;&#10;        ToggleGameMusicWithFade(true);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Starts playing menu music if available&#10;    /// &lt;/summary&gt;&#10;    private void PlayMenuMusic()&#10;    {&#10;        if (menuMusicSource != null &amp;&amp; !menuMusicSource.isPlaying)&#10;        {&#10;            menuMusicSource.Play();&#10;            Debug.Log(&quot;[MainMenu] Started menu music&quot;);&#10;        }&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Stops playing menu music&#10;    /// &lt;/summary&gt;&#10;    private void StopMenuMusic()&#10;    {&#10;        if (menuMusicSource != null &amp;&amp; menuMusicSource.isPlaying)&#10;        {&#10;            menuMusicSource.Stop();&#10;            Debug.Log(&quot;[MainMenu] Stopped menu music&quot;);&#10;        }&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Fades in pause music over the specified duration&#10;    /// &lt;/summary&gt;&#10;    private void PlayPauseMusicWithFadeIn()&#10;    {&#10;        if (pauseMusicSource == null) return;&#10;&#10;        // Stop any current pause music fade&#10;        if (pauseMusicFadeCoroutine != null)&#10;        {&#10;            StopCoroutine(pauseMusicFadeCoroutine);&#10;            pauseMusicFadeCoroutine = null;&#10;        }&#10;        &#10;        pauseMusicFadeCoroutine = StartCoroutine(FadeInMusic(pauseMusicSource, musicFadeInDuration, isGameOverMusic: false));&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Fades out pause music over the specified duration&#10;    /// &lt;/summary&gt;&#10;    private void StopPauseMusicWithFadeOut()&#10;    {&#10;        if (pauseMusicSource == null) return;&#10;&#10;        // Stop any current pause music fade&#10;        if (pauseMusicFadeCoroutine != null)&#10;        {&#10;            StopCoroutine(pauseMusicFadeCoroutine);&#10;            pauseMusicFadeCoroutine = null;&#10;        }&#10;        &#10;        pauseMusicFadeCoroutine = StartCoroutine(FadeOutMusic(pauseMusicSource, musicFadeOutDuration, isGameOverMusic: false));&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Fades in game over music after a delay&#10;    /// &lt;/summary&gt;&#10;    private void PlayGameOverMusicWithFadeIn()&#10;    {&#10;        if (gameOverMusicSource == null) return;&#10;&#10;        // Stop any current game over music fade&#10;        if (gameOverMusicFadeCoroutine != null)&#10;        {&#10;            StopCoroutine(gameOverMusicFadeCoroutine);&#10;            gameOverMusicFadeCoroutine = null;&#10;        }&#10;        &#10;        gameOverMusicFadeCoroutine = StartCoroutine(PlayGameOverMusicWithDelayCoroutine());&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Coroutine to delay then fade in game over music&#10;    /// &lt;/summary&gt;&#10;    private System.Collections.IEnumerator PlayGameOverMusicWithDelayCoroutine()&#10;    {&#10;        Debug.Log($&quot;[MainMenu] Waiting {gameOverMusicDelay} seconds before fading in game over music&quot;);&#10;        yield return new WaitForSecondsRealtime(gameOverMusicDelay);&#10;        if (gameOverMusicSource != null)&#10;        {&#10;            Debug.Log(&quot;[MainMenu] Starting game over music fade-in&quot;);&#10;            yield return FadeInMusic(gameOverMusicSource, musicFadeInDuration, isGameOverMusic: true);&#10;        }&#10;        &#10;        gameOverMusicFadeCoroutine = null;&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Fades out game over music over the specified duration&#10;    /// &lt;/summary&gt;&#10;    private void StopGameOverMusicWithFadeOut()&#10;    {&#10;        if (gameOverMusicSource == null) return;&#10;&#10;        // Stop any current game over music fade&#10;        if (gameOverMusicFadeCoroutine != null)&#10;        {&#10;            StopCoroutine(gameOverMusicFadeCoroutine);&#10;            gameOverMusicFadeCoroutine = null;&#10;        }&#10;        &#10;        gameOverMusicFadeCoroutine = StartCoroutine(FadeOutMusic(gameOverMusicSource, musicFadeOutDuration, isGameOverMusic: true));&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Coroutine to fade in an audio source&#10;    /// &lt;/summary&gt;&#10;    private System.Collections.IEnumerator FadeInMusic(AudioSource audioSource, float duration, bool isGameOverMusic)&#10;    {&#10;        if (audioSource == null) yield break;&#10;        &#10;        Debug.Log($&quot;[MainMenu] Fading in {audioSource.name} over {duration} seconds&quot;);&#10;        &#10;        // Start playing if not already&#10;        if (!audioSource.isPlaying)&#10;        {&#10;            audioSource.volume = 0f;&#10;            audioSource.Play();&#10;        }&#10;        &#10;        float startVolume = audioSource.volume;&#10;        float targetVolume = 0.4f; // was 1f, but it was too loud&#10;        float elapsed = 0f;&#10;        &#10;        while (elapsed &lt; duration)&#10;        {&#10;            elapsed += Time.unscaledDeltaTime;&#10;            float fadeProgress = elapsed / duration;&#10;            audioSource.volume = Mathf.Lerp(startVolume, targetVolume, fadeProgress);&#10;            yield return null;&#10;        }&#10;        &#10;        audioSource.volume = targetVolume;&#10;        Debug.Log($&quot;[MainMenu] Fade in complete for {audioSource.name}&quot;);&#10;        &#10;        // Clear the tracking reference&#10;        if (isGameOverMusic)&#10;            gameOverMusicFadeCoroutine = null;&#10;        else&#10;            pauseMusicFadeCoroutine = null;&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Coroutine to fade out an audio source&#10;    /// &lt;/summary&gt;&#10;    private System.Collections.IEnumerator FadeOutMusic(AudioSource audioSource, float duration, bool isGameOverMusic, bool stopMusic = true)&#10;    {&#10;        if (audioSource == null) yield break;&#10;        &#10;        Debug.Log($&quot;[MainMenu] Fading out {audioSource.name} over {duration} seconds - start volume: {audioSource.volume}&quot;);&#10;        &#10;        float startVolume = audioSource.volume;&#10;        float targetVolume = 0f;&#10;        float elapsed = 0f;&#10;        &#10;        while (elapsed &lt; duration)&#10;        {&#10;            elapsed += Time.unscaledDeltaTime;&#10;            float fadeProgress = elapsed / duration;&#10;            audioSource.volume = Mathf.Lerp(startVolume, targetVolume, fadeProgress);&#10;            Debug.Log($&quot;[MainMenu] Fade out progress: {fadeProgress:F2}, volume: {audioSource.volume:F2}&quot;);&#10;            yield return null;&#10;        }&#10;        &#10;        audioSource.volume = targetVolume;&#10;        if(stopMusic)&#10;        {&#10;            audioSource.Stop();&#10;        }&#10;&#10;        Debug.Log($&quot;[MainMenu] Fade out complete for {audioSource.name}&quot;);&#10;        &#10;        // Clear the tracking reference&#10;        if (isGameOverMusic)&#10;            gameOverMusicFadeCoroutine = null;&#10;        else&#10;            pauseMusicFadeCoroutine = null;&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Unmute gameplay audio after a delay (for retry functionality)&#10;    /// &lt;/summary&gt;&#10;    private System.Collections.IEnumerator UnmuteGameplayAudioDelayed(float delay)&#10;    {&#10;        Debug.Log($&quot;[MainMenu] Delaying gameplay audio unmute by {delay} seconds&quot;);&#10;        yield return new WaitForSecondsRealtime(delay);&#10;        UnmuteGameplayAudio();&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Mute gameplay audio after a delay with fade-out effect (for when player is caught)&#10;    /// &lt;/summary&gt;&#10;    private System.Collections.IEnumerator MuteGameplayAudioDelayed(float delay)&#10;    {&#10;        Debug.Log($&quot;[MainMenu] Fading out gameplay audio over {delay} seconds&quot;);&#10;        &#10;        // Find all gameplay audio sources&#10;        AudioSource[] allAudioSources = FindObjectsByType&lt;AudioSource&gt;(FindObjectsInactive.Include, FindObjectsSortMode.None);&#10;        &#10;        // Store original volumes and filter to gameplay sources only&#10;        System.Collections.Generic.List&lt;AudioSource&gt; gameplayAudioSources = new System.Collections.Generic.List&lt;AudioSource&gt;();&#10;        System.Collections.Generic.Dictionary&lt;AudioSource, float&gt; originalVolumes = new System.Collections.Generic.Dictionary&lt;AudioSource, float&gt;();&#10;        &#10;        foreach (AudioSource audioSource in allAudioSources)&#10;        {&#10;            // Skip the menu music source&#10;            if (audioSource == menuMusicSource) continue;&#10;            &#10;            // Only include gameplay audio sources&#10;            if (audioSource.gameObject.scene.name == gameplaySceneName || &#10;                audioSource.CompareTag(gameplayAudioTag))&#10;            {&#10;                gameplayAudioSources.Add(audioSource);&#10;                originalVolumes[audioSource] = audioSource.volume;&#10;            }&#10;        }&#10;        &#10;        // Fade out over the delay duration&#10;        float elapsed = 0f;&#10;        while (elapsed &lt; delay)&#10;        {&#10;            elapsed += Time.unscaledDeltaTime; // Use unscaledDeltaTime in case game is paused&#10;            float fadeProgress = elapsed / delay; // 0 to 1&#10;            float volumeMultiplier = 1f - fadeProgress; // 1 to 0&#10;            &#10;            // Apply fade to all gameplay audio sources&#10;            foreach (AudioSource audioSource in gameplayAudioSources)&#10;            {&#10;                if (audioSource != null &amp;&amp; originalVolumes.ContainsKey(audioSource))&#10;                {&#10;                    audioSource.volume = originalVolumes[audioSource] * volumeMultiplier;&#10;                }&#10;            }&#10;            if (!isRetrying)&#10;            {&#10;                yield break; // Exit early if player is retrying&#10;            }&#10;            yield return null; // Wait one frame&#10;        }&#10;        &#10;        // Ensure all volumes are at 0 and mute them&#10;        foreach (AudioSource audioSource in gameplayAudioSources)&#10;        {&#10;            if (audioSource != null)&#10;            {&#10;                audioSource.volume = 0f;&#10;            }&#10;        }&#10;        &#10;        // Finally, mute all gameplay audio&#10;        MuteGameplayAudio();&#10;        &#10;        Debug.Log(&quot;[MainMenu] Gameplay audio fade-out complete&quot;);&#10;    }&#10;    &#10;    #endregion&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/docs/RechargeAnimationSetupGuide.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/docs/RechargeAnimationSetupGuide.md" />
              <option name="updatedContent" value="# Recharge Animation Setup Guide&#10;&#10;## Issue Fixed&#10;✅ **Bug Found**: `EnergyBehaviour.cs` was calling `guardAnimation.Run()` instead of `guardAnimation.Recharge()`&#10;✅ **Fixed**: Now correctly calls `guardAnimation.Recharge()`&#10;&#10;## Unity Animator Setup Checklist&#10;&#10;Follow these steps to verify your Animator Controller is set up correctly:&#10;&#10;### 1. Check Animator Controller Has &quot;Recharging&quot; Trigger&#10;&#10;**Steps:**&#10;1. Select your Guard prefab in the scene&#10;2. Find the `Animator` component (usually on the model/root)&#10;3. Double-click the **Controller** field to open the Animator window&#10;4. In the **Parameters** tab (top-left), verify you have a parameter named **&quot;Recharging&quot;**&#10;5. The type should be **Trigger**&#10;&#10;**Screenshot Reference Location:**&#10;- Parameters Tab → Should show: `Recharging (Trigger)`&#10;&#10;✅ **Expected:** Parameter named exactly &quot;Recharging&quot; exists as a Trigger&#10;❌ **Problem:** If missing, parameter doesn't exist&#10;❌ **Problem:** If wrong name (e.g., &quot;Recharge&quot; instead of &quot;Recharging&quot;), won't trigger&#10;&#10;### 2. Check Recharging Animation State Exists&#10;&#10;**Steps:**&#10;1. In the Animator window, look at the state machine diagram&#10;2. Find a state named something like &quot;Recharging&quot;, &quot;Recharge&quot;, or similar&#10;3. This state should contain your recharge animation clip&#10;&#10;**Expected States:**&#10;```&#10;- Idle (or similar default state)&#10;- Walking&#10;- Running  &#10;- Searching&#10;- Recharging  ← Must exist!&#10;```&#10;&#10;✅ **Expected:** A state exists for the recharge animation&#10;❌ **Problem:** If missing, create a new state and assign your recharge animation clip&#10;&#10;### 3. Check Transition FROM Current States TO Recharging&#10;&#10;**Critical:** You need transitions that respond to the &quot;Recharging&quot; trigger&#10;&#10;**Steps:**&#10;1. Check transitions FROM these states TO Recharging state:&#10;   - Idle → Recharging&#10;   - Walking → Recharging&#10;   - Running → Recharging&#10;   - Searching → Recharging&#10;   - (Any state the guard might be in) → Recharging&#10;&#10;2. For each transition, verify:&#10;   - **Condition:** Uses the &quot;Recharging&quot; trigger&#10;   - **Has Exit Time:** Unchecked (for immediate response)&#10;   - **Transition Duration:** Short (0.1-0.25 seconds)&#10;   - **Interruption Source:** Current State (allows interruption)&#10;&#10;**Quick Test:**&#10;- Right-click on Idle state → **Make Transition** → Click Recharging state&#10;- Select the transition arrow&#10;- In Inspector, click **+** under Conditions&#10;- Add condition: **Recharging**&#10;&#10;### 4. Check Transition FROM Recharging BACK TO Idle&#10;&#10;**Steps:**&#10;1. Find transition: Recharging → Idle&#10;2. Verify settings:&#10;   - **Condition:** Uses the &quot;Idle&quot; trigger&#10;   - **Has Exit Time:** Can be checked or unchecked (depends on your preference)&#10;   - **Transition Duration:** 0.1-0.25 seconds&#10;&#10;**Alternative:** Some setups use &quot;Any State&quot; → Idle transition&#10;&#10;### 5. Verify GuardAnimation Component Setup&#10;&#10;**On your Guard GameObject:**&#10;1. Find the `GuardAnimation` component&#10;2. Check the **Animator** field is assigned&#10;3. The Animator should reference the same Animator component from step 1&#10;&#10;**Inspector View:**&#10;```&#10;GuardAnimation (Script)&#10;├─ Animator: [Reference to Animator component]&#10;```&#10;&#10;✅ **Expected:** Animator field is populated&#10;❌ **Problem:** If empty, drag the Animator component into this field&#10;&#10;### 6. Test Animation Triggering Manually&#10;&#10;**In Play Mode:**&#10;1. Select the Guard in hierarchy&#10;2. Find the `GuardAnimation` component in Inspector&#10;3. Right-click on the component header&#10;4. Choose **&quot;Recharge&quot;** from the context menu (if available)&#10;5. Watch the Animator window to see if transition happens&#10;&#10;**Alternative Test:**&#10;1. Open Console window&#10;2. Enter Play Mode&#10;3. Wait for guard to need recharge&#10;4. Look for this log: `[EnergyBehaviour] Guard_01 triggering Recharge animation`&#10;4. Open Animator window with guard selected&#10;5. Watch the state transitions in real-time&#10;&#10;### 7. Common Issues &amp; Fixes&#10;&#10;#### Issue: &quot;Recharging&quot; trigger exists but animation doesn't play&#10;&#10;**Possible Causes:**&#10;1. **No transition exists** → Add transitions (see step 3)&#10;2. **Transition has conditions that block it** → Check conditions on transitions&#10;3. **Has Exit Time checked** → Uncheck for immediate response&#10;4. **Wrong parameter name** → Must be exactly &quot;Recharging&quot; (case-sensitive)&#10;&#10;#### Issue: Animation plays but loops weirdly&#10;&#10;**Possible Causes:**&#10;1. **Animation clip Loop Time enabled** → Select animation clip in Project, uncheck Loop Time if it shouldn't loop&#10;2. **Recharging state doesn't transition out** → Verify transition back to Idle exists&#10;&#10;#### Issue: Animation plays but flashlight doesn't disable&#10;&#10;**Solution:**&#10;- This is handled by Animation Events on the animation clip&#10;- Select your recharge animation clip&#10;- In the Animation window, add events to call functions that disable/enable flashlight&#10;- OR handle flashlight in script (which you've already done with spotlight management)&#10;&#10;## Quick Reference: GuardAnimation.cs&#10;&#10;Your `Recharge()` method should look like this:&#10;&#10;```csharp&#10;public void Recharge()&#10;{&#10;    // Always set trigger - no state check blocking&#10;    animator.SetTrigger(&quot;Recharging&quot;);&#10;    currentState = AnimationState.Recharging;&#10;}&#10;```&#10;&#10;✅ **This is correct** - Always triggers regardless of current state&#10;✅ **This matches** your other animation methods (Walk, Run, Idle, Search)&#10;&#10;## Testing Procedure&#10;&#10;### Step-by-Step Test:&#10;&#10;1. **Enter Play Mode**&#10;2. **Check Initial State:**&#10;   - Console should show: `[EnergyBehaviour] Guard_01 recharging set to: False`&#10;   - Guard should be in Idle or Walking animation&#10;&#10;3. **Wait for Energy to Drain:**&#10;   - Watch Inspector: EnergyBehaviour → Current Energy dropping&#10;&#10;4. **When Recharge Starts:**&#10;   - Console should show: `[EnergyBehaviour] Guard_01 recharging set to: True`&#10;   - Console should show: `[EnergyBehaviour] Guard_01 triggering Recharge animation`&#10;   - Console should show: `[RechargeAction] Guard_01 started recharging...`&#10;&#10;5. **Watch Animator Window:**&#10;   - State should transition to &quot;Recharging&quot; state&#10;   - Should see transition line highlight&#10;   - Should see current state indicator on Recharging state&#10;&#10;6. **When Recharge Completes:**&#10;   - Console should show: `[EnergyBehaviour] Guard_01 recharge complete, returning to Idle animation`&#10;   - Console should show: `[RechargeAction] Guard_01 fully recharged!`&#10;   - Console should show: `[EnergyBehaviour] Guard_01 triggering Idle animation`&#10;   - Animator should transition back to Idle&#10;&#10;### Expected Console Output:&#10;```&#10;[RechargeAction] Guard_01 started recharging on the spot (Energy: 5.2/100.0)&#10;[EnergyBehaviour] Guard_01 recharging set to: True&#10;[EnergyBehaviour] Guard_01 triggering Recharge animation&#10;... (wait for recharge) ...&#10;[EnergyBehaviour] Guard_01 recharge complete, returning to Idle animation&#10;[RechargeAction] Guard_01 fully recharged!&#10;[RechargeAction] Guard_01 ending recharge action&#10;[EnergyBehaviour] Guard_01 recharging set to: False&#10;[EnergyBehaviour] Guard_01 triggering Idle animation&#10;```&#10;&#10;## Troubleshooting Decision Tree&#10;&#10;```&#10;Animation not playing?&#10;│&#10;├─ Check Console logs&#10;│  ├─ No &quot;triggering Recharge animation&quot; log&#10;│  │  └─&gt; GuardAnimation component missing or not assigned&#10;│  │&#10;│  └─ Log appears but no animation&#10;│     └─&gt; Animator Controller issue (see below)&#10;│&#10;├─ Open Animator window in Play mode&#10;│  ├─ Transition doesn't happen&#10;│  │  ├─&gt; No transition exists → Add it&#10;│  │  └─&gt; Transition blocked → Check conditions&#10;│  │&#10;│  └─ Transition happens but wrong animation plays&#10;│     └─&gt; Wrong animation clip assigned to state&#10;│&#10;└─ Check Animator Parameters&#10;   ├─ &quot;Recharging&quot; parameter missing → Create it&#10;   ├─&gt; Wrong type (not Trigger) → Change to Trigger&#10;   └─&gt; Typo in name → Rename to exactly &quot;Recharging&quot;&#10;```&#10;&#10;## Summary&#10;&#10;✅ **Code is now correct** - `guardAnimation.Recharge()` is called&#10;✅ **GuardAnimation.cs** - Correctly sets trigger without blocking&#10;✅ **Now verify Unity setup** - Follow checklist above&#10;&#10;The most common issue is missing transitions in the Animator Controller. Make sure ALL states that the guard might be in have transitions TO the Recharging state with the &quot;Recharging&quot; trigger condition.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>